"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zod";
exports.ids = ["vendor-chunks/zod"];
exports.modules = {

/***/ "(ssr)/./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: () => (/* binding */ BRAND),\n/* harmony export */   DIRTY: () => (/* binding */ DIRTY),\n/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),\n/* harmony export */   INVALID: () => (/* binding */ INVALID),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   OK: () => (/* binding */ OK),\n/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),\n/* harmony export */   Schema: () => (/* binding */ ZodType),\n/* harmony export */   ZodAny: () => (/* binding */ ZodAny),\n/* harmony export */   ZodArray: () => (/* binding */ ZodArray),\n/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),\n/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),\n/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),\n/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),\n/* harmony export */   ZodDate: () => (/* binding */ ZodDate),\n/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),\n/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),\n/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),\n/* harmony export */   ZodError: () => (/* binding */ ZodError),\n/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),\n/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),\n/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),\n/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),\n/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),\n/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),\n/* harmony export */   ZodMap: () => (/* binding */ ZodMap),\n/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),\n/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),\n/* harmony export */   ZodNever: () => (/* binding */ ZodNever),\n/* harmony export */   ZodNull: () => (/* binding */ ZodNull),\n/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),\n/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),\n/* harmony export */   ZodObject: () => (/* binding */ ZodObject),\n/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),\n/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),\n/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),\n/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),\n/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),\n/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),\n/* harmony export */   ZodSchema: () => (/* binding */ ZodType),\n/* harmony export */   ZodSet: () => (/* binding */ ZodSet),\n/* harmony export */   ZodString: () => (/* binding */ ZodString),\n/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),\n/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),\n/* harmony export */   ZodType: () => (/* binding */ ZodType),\n/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),\n/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),\n/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),\n/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),\n/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),\n/* harmony export */   any: () => (/* binding */ anyType),\n/* harmony export */   array: () => (/* binding */ arrayType),\n/* harmony export */   bigint: () => (/* binding */ bigIntType),\n/* harmony export */   boolean: () => (/* binding */ booleanType),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   date: () => (/* binding */ dateType),\n/* harmony export */   datetimeRegex: () => (/* binding */ datetimeRegex),\n/* harmony export */   \"default\": () => (/* binding */ z),\n/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),\n/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),\n/* harmony export */   effect: () => (/* binding */ effectsType),\n/* harmony export */   \"enum\": () => (/* binding */ enumType),\n/* harmony export */   \"function\": () => (/* binding */ functionType),\n/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),\n/* harmony export */   getParsedType: () => (/* binding */ getParsedType),\n/* harmony export */   \"instanceof\": () => (/* binding */ instanceOfType),\n/* harmony export */   intersection: () => (/* binding */ intersectionType),\n/* harmony export */   isAborted: () => (/* binding */ isAborted),\n/* harmony export */   isAsync: () => (/* binding */ isAsync),\n/* harmony export */   isDirty: () => (/* binding */ isDirty),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   late: () => (/* binding */ late),\n/* harmony export */   lazy: () => (/* binding */ lazyType),\n/* harmony export */   literal: () => (/* binding */ literalType),\n/* harmony export */   makeIssue: () => (/* binding */ makeIssue),\n/* harmony export */   map: () => (/* binding */ mapType),\n/* harmony export */   nan: () => (/* binding */ nanType),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),\n/* harmony export */   never: () => (/* binding */ neverType),\n/* harmony export */   \"null\": () => (/* binding */ nullType),\n/* harmony export */   nullable: () => (/* binding */ nullableType),\n/* harmony export */   number: () => (/* binding */ numberType),\n/* harmony export */   object: () => (/* binding */ objectType),\n/* harmony export */   objectUtil: () => (/* binding */ objectUtil),\n/* harmony export */   oboolean: () => (/* binding */ oboolean),\n/* harmony export */   onumber: () => (/* binding */ onumber),\n/* harmony export */   optional: () => (/* binding */ optionalType),\n/* harmony export */   ostring: () => (/* binding */ ostring),\n/* harmony export */   pipeline: () => (/* binding */ pipelineType),\n/* harmony export */   preprocess: () => (/* binding */ preprocessType),\n/* harmony export */   promise: () => (/* binding */ promiseType),\n/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),\n/* harmony export */   record: () => (/* binding */ recordType),\n/* harmony export */   set: () => (/* binding */ setType),\n/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),\n/* harmony export */   strictObject: () => (/* binding */ strictObjectType),\n/* harmony export */   string: () => (/* binding */ stringType),\n/* harmony export */   symbol: () => (/* binding */ symbolType),\n/* harmony export */   transformer: () => (/* binding */ effectsType),\n/* harmony export */   tuple: () => (/* binding */ tupleType),\n/* harmony export */   undefined: () => (/* binding */ undefinedType),\n/* harmony export */   union: () => (/* binding */ unionType),\n/* harmony export */   unknown: () => (/* binding */ unknownType),\n/* harmony export */   util: () => (/* binding */ util),\n/* harmony export */   \"void\": () => (/* binding */ voidType),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\nvar util;\n(function(util) {\n    util.assertEqual = (val)=>val;\n    function assertIs(_arg) {}\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items)=>{\n        const obj = {};\n        for (const item of items){\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj)=>{\n        const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys){\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj)=>{\n        return util.objectKeys(obj).map(function(e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n     ? (obj)=>Object.keys(obj) // eslint-disable-line ban/ban\n     : (object)=>{\n        const keys = [];\n        for(const key in object){\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    util.find = (arr, checker)=>{\n        for (const item of arr){\n            if (checker(item)) return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\" ? (val)=>Number.isInteger(val) // eslint-disable-line ban/ban\n     : (val)=>typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val)=>typeof val === \"string\" ? `'${val}'` : val).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value)=>{\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil) {\n    objectUtil.mergeShapes = (first, second)=>{\n        return {\n            ...first,\n            ...second\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\"\n]);\nconst getParsedType = (data)=>{\n    const t = typeof data;\n    switch(t){\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\"\n]);\nconst quotelessJson = (obj)=>{\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues){\n        super();\n        this.issues = [];\n        this.addIssue = (sub)=>{\n            this.issues = [\n                ...this.issues,\n                sub\n            ];\n        };\n        this.addIssues = (subs = [])=>{\n            this.issues = [\n                ...this.issues,\n                ...subs\n            ];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        } else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper || function(issue) {\n            return issue.message;\n        };\n        const fieldErrors = {\n            _errors: []\n        };\n        const processError = (error)=>{\n            for (const issue of error.issues){\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                } else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                } else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                } else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                } else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while(i < issue.path.length){\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                        // if (typeof el === \"string\") {\n                        //   curr[el] = curr[el] || { _errors: [] };\n                        // } else if (typeof el === \"number\") {\n                        //   const errorArray: any = [];\n                        //   errorArray._errors = [];\n                        //   curr[el] = curr[el] || errorArray;\n                        // }\n                        } else {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue)=>issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues){\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            } else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return {\n            formErrors,\n            fieldErrors\n        };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues)=>{\n    const error = new ZodError(issues);\n    return error;\n};\nconst errorMap = (issue, _ctx)=>{\n    let message;\n    switch(issue.code){\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            } else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                } else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                } else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                } else {\n                    util.assertNever(issue.validation);\n                }\n            } else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            } else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\") message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\") message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return {\n        message\n    };\n};\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\nconst makeIssue = (params)=>{\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [\n        ...path,\n        ...issueData.path || []\n    ];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps.filter((m)=>!!m).slice().reverse();\n    for (const map of maps){\n        errorMessage = map(fullIssue, {\n            data,\n            defaultError: errorMessage\n        }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            overrideMap,\n            overrideMap === errorMap ? undefined : errorMap\n        ].filter((x)=>!!x)\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor(){\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\") this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\") this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results){\n            if (s.status === \"aborted\") return INVALID;\n            if (s.status === \"dirty\") status.dirty();\n            arrayValue.push(s.value);\n        }\n        return {\n            status: status.value,\n            value: arrayValue\n        };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs){\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs){\n            const { key, value } = pair;\n            if (key.status === \"aborted\") return INVALID;\n            if (value.status === \"aborted\") return INVALID;\n            if (key.status === \"dirty\") status.dirty();\n            if (value.status === \"dirty\") status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return {\n            status: status.value,\n            value: finalObject\n        };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\"\n});\nconst DIRTY = (value)=>({\n        status: \"dirty\",\n        value\n    });\nconst OK = (value)=>({\n        status: \"valid\",\n        value\n    });\nconst isAborted = (x)=>x.status === \"aborted\";\nconst isDirty = (x)=>x.status === \"dirty\";\nconst isValid = (x)=>x.status === \"valid\";\nconst isAsync = (x)=>typeof Promise !== \"undefined\" && x instanceof Promise;\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar errorUtil;\n(function(errorUtil) {\n    errorUtil.errToObj = (message)=>typeof message === \"string\" ? {\n            message\n        } : message || {};\n    errorUtil.toString = (message)=>typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nvar _ZodEnum_cache, _ZodNativeEnum_cache;\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key){\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            } else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result)=>{\n    if (isValid(result)) {\n        return {\n            success: true,\n            data: result.value\n        };\n    } else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error () {\n                if (this._error) return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            }\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params) return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap) return {\n        errorMap: errorMap,\n        description\n    };\n    const customMap = (iss, ctx)=>{\n        var _a, _b;\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return {\n                message: message !== null && message !== void 0 ? message : ctx.defaultError\n            };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return {\n                message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError\n            };\n        }\n        if (iss.code !== \"invalid_type\") return {\n            message: ctx.defaultError\n        };\n        return {\n            message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError\n        };\n    };\n    return {\n        errorMap: customMap,\n        description\n    };\n}\nclass ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent\n        };\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent\n            }\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const result = this._parseSync({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        var _a, _b;\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({\n                    data,\n                    path: [],\n                    parent: ctx\n                });\n                return isValid(result) ? {\n                    value: result.value\n                } : {\n                    issues: ctx.common.issues\n                };\n            } catch (err) {\n                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true\n                };\n            }\n        }\n        return this._parseAsync({\n            data,\n            path: [],\n            parent: ctx\n        }).then((result)=>isValid(result) ? {\n                value: result.value\n            } : {\n                issues: ctx.common.issues\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const maybeAsyncResult = this._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val)=>{\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return {\n                    message\n                };\n            } else if (typeof message === \"function\") {\n                return message(val);\n            } else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx)=>{\n            const result = check(val);\n            const setError = ()=>ctx.addIssue({\n                    code: ZodIssueCode.custom,\n                    ...getIssueProperties(val)\n                });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data)=>{\n                    if (!data) {\n                        setError();\n                        return false;\n                    } else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx)=>{\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"refinement\",\n                refinement\n            }\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def){\n        /** Alias of safeParseAsync */ this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data)=>this[\"~validate\"](data)\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([\n            this,\n            option\n        ], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"transform\",\n                transform\n            }\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def)\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    } else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nfunction datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset) opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt)) return false;\n    try {\n        const [header] = jwt.split(\".\");\n        // Convert base64url to base64\n        const base64 = header.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(header.length + (4 - header.length % 4) % 4, \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null) return false;\n        if (!decoded.typ || !decoded.alg) return false;\n        if (alg && decoded.alg !== alg) return false;\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    } else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    }\n                    status.dirty();\n                }\n            } else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                } catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            } else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            includes: check.value,\n                            position: check.position\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            } else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            } else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            startsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            endsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data)=>regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    email(message) {\n        return this._addCheck({\n            kind: \"email\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    url(message) {\n        return this._addCheck({\n            kind: \"url\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    emoji(message) {\n        return this._addCheck({\n            kind: \"emoji\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    uuid(message) {\n        return this._addCheck({\n            kind: \"uuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    nanoid(message) {\n        return this._addCheck({\n            kind: \"nanoid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid(message) {\n        return this._addCheck({\n            kind: \"cuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid2(message) {\n        return this._addCheck({\n            kind: \"cuid2\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    ulid(message) {\n        return this._addCheck({\n            kind: \"ulid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    base64(message) {\n        return this._addCheck({\n            kind: \"base64\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    jwt(options) {\n        return this._addCheck({\n            kind: \"jwt\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    ip(options) {\n        return this._addCheck({\n            kind: \"ip\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    cidr(options) {\n        return this._addCheck({\n            kind: \"cidr\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    datetime(options) {\n        var _a, _b;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    date(message) {\n        return this._addCheck({\n            kind: \"date\",\n            message\n        });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    duration(message) {\n        return this._addCheck({\n            kind: \"duration\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */ nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"trim\"\n                }\n            ]\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toLowerCase\"\n                }\n            ]\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toUpperCase\"\n                }\n            ]\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch)=>ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params)=>{\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return valInt % stepInt / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message)\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message)\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message)\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            } else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            } else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params)=>{\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            } catch (_a) {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params)=>{\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params)=>{\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime())\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params)=>{\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params)\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params)=>{\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params)=>{\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params)=>{\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params)\n    });\n};\nclass ZodAny extends ZodType {\n    constructor(){\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params)=>{\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor(){\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params)=>{\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params)=>{\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params)\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params)=>{\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params)\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: tooSmall ? def.exactLength.value : undefined,\n                    maximum: tooBig ? def.exactLength.value : undefined,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([\n                ...ctx.data\n            ].map((item, i)=>{\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result)=>{\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [\n            ...ctx.data\n        ].map((item, i)=>{\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: {\n                value: minLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: {\n                value: maxLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: {\n                value: len,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params)=>{\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params)\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for(const key in schema.shape){\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: ()=>newShape\n        });\n    } else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element)\n        });\n    } else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));\n    } else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor(){\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */ this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */ this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null) return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return this._cached = {\n            shape,\n            keys\n        };\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for(const key in ctx.data){\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys){\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: {\n                    status: \"valid\",\n                    value: key\n                },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys){\n                    pairs.push({\n                        key: {\n                            status: \"valid\",\n                            value: key\n                        },\n                        value: {\n                            status: \"valid\",\n                            value: ctx.data[key]\n                        }\n                    });\n                }\n            } else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys\n                    });\n                    status.dirty();\n                }\n            } else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        } else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys){\n                const value = ctx.data[key];\n                pairs.push({\n                    key: {\n                        status: \"valid\",\n                        value: key\n                    },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve().then(async ()=>{\n                const syncPairs = [];\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet\n                    });\n                }\n                return syncPairs;\n            }).then((syncPairs)=>{\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...message !== undefined ? {\n                errorMap: (issue, ctx)=>{\n                    var _a, _b, _c, _d;\n                    const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                    if (issue.code === \"unrecognized_keys\") return {\n                        message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\n                    };\n                    return {\n                        message: defaultError\n                    };\n                }\n            } : {}\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\"\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\"\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...augmentation\n                })\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */ merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...merging._def.shape()\n                }),\n            typeName: ZodFirstPartyTypeKind.ZodObject\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({\n            [key]: schema\n        });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key)=>{\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    /**\n     * @deprecated\n     */ deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            } else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            } else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while(newField instanceof ZodOptional){\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.strictCreate = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.lazycreate = (shape, params)=>{\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results){\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results){\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option)=>{\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx\n                    }),\n                    ctx: childCtx\n                };\n            })).then(handleResults);\n        } else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options){\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                } else if (result.status === \"dirty\" && !dirty) {\n                    dirty = {\n                        result,\n                        ctx: childCtx\n                    };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues)=>new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params)=>{\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params)\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type)=>{\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    } else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    } else if (type instanceof ZodLiteral) {\n        return [\n            type.value\n        ];\n    } else if (type instanceof ZodEnum) {\n        return type.options;\n    } else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    } else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    } else if (type instanceof ZodUndefined) {\n        return [\n            undefined\n        ];\n    } else if (type instanceof ZodNull) {\n        return [\n            null\n        ];\n    } else if (type instanceof ZodOptional) {\n        return [\n            undefined,\n            ...getDiscriminator(type.unwrap())\n        ];\n    } else if (type instanceof ZodNullable) {\n        return [\n            null,\n            ...getDiscriminator(type.unwrap())\n        ];\n    } else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    } else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    } else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    } else {\n        return [];\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [\n                    discriminator\n                ]\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        } else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */ static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options){\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues){\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params)\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);\n        const newObj = {\n            ...a,\n            ...b\n        };\n        for (const key of sharedKeys){\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return {\n            valid: true,\n            data: newObj\n        };\n    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return {\n                valid: false\n            };\n        }\n        const newArray = [];\n        for(let index = 0; index < a.length; index++){\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return {\n            valid: true,\n            data: newArray\n        };\n    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else {\n        return {\n            valid: false\n        };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight)=>{\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return {\n                status: status.value,\n                value: merged.data\n            };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                })\n            ]).then(([left, right])=>handleParsed(left, right));\n        } else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params)=>{\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params)\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            status.dirty();\n        }\n        const items = [\n            ...ctx.data\n        ].map((item, itemIndex)=>{\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema) return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        }).filter((x)=>!!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results)=>{\n                return ParseStatus.mergeArray(status, results);\n            });\n        } else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest\n        });\n    }\n}\nZodTuple.create = (schemas, params)=>{\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params)\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for(const key in ctx.data){\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third)\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second)\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [\n            ...ctx.data.entries()\n        ].map(([key, value], index)=>{\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [\n                    index,\n                    \"key\"\n                ])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [\n                    index,\n                    \"value\"\n                ]))\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async ()=>{\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return {\n                    status: status.value,\n                    value: finalMap\n                };\n            });\n        } else {\n            const finalMap = new Map();\n            for (const pair of pairs){\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return {\n                status: status.value,\n                value: finalMap\n            };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params)=>{\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params)\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements){\n                if (element.status === \"aborted\") return INVALID;\n                if (element.status === \"dirty\") status.dirty();\n                parsedSet.add(element.value);\n            }\n            return {\n                status: status.value,\n                value: parsedSet\n            };\n        }\n        const elements = [\n            ...ctx.data.values()\n        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements)=>finalizeSet(elements));\n        } else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: {\n                value: minSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: {\n                value: maxSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params)=>{\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params)\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error\n                }\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error\n                }\n            });\n        }\n        const params = {\n            errorMap: ctx.common.contextualErrorMap\n        };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function(...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        } else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function(...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([\n                        makeArgsIssue(args, parsedArgs.error)\n                    ]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([\n                        makeReturnsIssue(result, parsedReturns.error)\n                    ]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create())\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params)\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n}\nZodLazy.create = (getter, params)=>{\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params)\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params)=>{\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params)\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params)\n    });\n}\nclass ZodEnum extends ZodType {\n    constructor(){\n        super(...arguments);\n        _ZodEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {\n            ...this._def,\n            ...newDef\n        });\n    }\n}\n_ZodEnum_cache = new WeakMap();\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    constructor(){\n        super(...arguments);\n        _ZodNativeEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\n_ZodNativeEnum_cache = new WeakMap();\nZodNativeEnum.create = (values, params)=>{\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params)\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data)=>{\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params)=>{\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params)\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg)=>{\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                } else {\n                    status.dirty();\n                }\n            },\n            get path () {\n                return ctx.path;\n            }\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed)=>{\n                    if (status.value === \"aborted\") return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                    if (result.status === \"aborted\") return INVALID;\n                    if (result.status === \"dirty\") return DIRTY(result.value);\n                    if (status.value === \"dirty\") return DIRTY(result.value);\n                    return result;\n                });\n            } else {\n                if (status.value === \"aborted\") return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (result.status === \"aborted\") return INVALID;\n                if (result.status === \"dirty\") return DIRTY(result.value);\n                if (status.value === \"dirty\") return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc)=>{\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inner.status === \"aborted\") return INVALID;\n                if (inner.status === \"dirty\") status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return {\n                    status: status.value,\n                    value: inner.value\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((inner)=>{\n                    if (inner.status === \"aborted\") return INVALID;\n                    if (inner.status === \"dirty\") status.dirty();\n                    return executeRefinement(inner.value).then(()=>{\n                        return {\n                            status: status.value,\n                            value: inner.value\n                        };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (!isValid(base)) return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return {\n                    status: status.value,\n                    value: result\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((base)=>{\n                    if (!isValid(base)) return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({\n                            status: status.value,\n                            value: result\n                        }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params)=>{\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params)\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params)=>{\n    return new ZodEffects({\n        schema,\n        effect: {\n            type: \"preprocess\",\n            transform: preprocess\n        },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params)\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params)=>{\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params)=>{\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params)\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params)=>{\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : ()=>params.default,\n        ...processCreateParams(params)\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: []\n            }\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx\n            }\n        });\n        if (isAsync(result)) {\n            return result.then((result)=>{\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\" ? result.value : this._def.catchValue({\n                        get error () {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data\n                    })\n                };\n            });\n        } else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\" ? result.value : this._def.catchValue({\n                    get error () {\n                        return new ZodError(newCtx.common.issues);\n                    },\n                    input: newCtx.data\n                })\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params)=>{\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : ()=>params.catch,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n}\nZodNaN.create = (params)=>{\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params)\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async ()=>{\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inResult.status === \"aborted\") return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                } else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                }\n            };\n            return handleAsync();\n        } else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n            if (inResult.status === \"aborted\") return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value\n                };\n            } else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data)=>{\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params)=>{\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params)\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? {\n        message: params\n    } : params;\n    const p2 = typeof p === \"string\" ? {\n        message: p\n    } : p;\n    return p2;\n}\nfunction custom(check, _params = {}, /**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */ fatal) {\n    if (check) return ZodAny.create().superRefine((data, ctx)=>{\n        var _a, _b;\n        const r = check(data);\n        if (r instanceof Promise) {\n            return r.then((r)=>{\n                var _a, _b;\n                if (!r) {\n                    const params = cleanParams(_params, data);\n                    const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                    ctx.addIssue({\n                        code: \"custom\",\n                        ...params,\n                        fatal: _fatal\n                    });\n                }\n            });\n        }\n        if (!r) {\n            const params = cleanParams(_params, data);\n            const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n            ctx.addIssue({\n                code: \"custom\",\n                ...params,\n                fatal: _fatal\n            });\n        }\n        return;\n    });\n    return ZodAny.create();\n}\nconst late = {\n    object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`\n})=>custom((data)=>data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = ()=>stringType().optional();\nconst onumber = ()=>numberType().optional();\nconst oboolean = ()=>booleanType().optional();\nconst coerce = {\n    string: (arg)=>ZodString.create({\n            ...arg,\n            coerce: true\n        }),\n    number: (arg)=>ZodNumber.create({\n            ...arg,\n            coerce: true\n        }),\n    boolean: (arg)=>ZodBoolean.create({\n            ...arg,\n            coerce: true\n        }),\n    bigint: (arg)=>ZodBigInt.create({\n            ...arg,\n            coerce: true\n        }),\n    date: (arg)=>ZodDate.create({\n            ...arg,\n            coerce: true\n        })\n};\nconst NEVER = INVALID;\nvar z = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () {\n        return util;\n    },\n    get objectUtil () {\n        return objectUtil;\n    },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    datetimeRegex: datetimeRegex,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () {\n        return ZodFirstPartyTypeKind;\n    },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    \"enum\": enumType,\n    \"function\": functionType,\n    \"instanceof\": instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    \"null\": nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    \"undefined\": undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    \"void\": voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBO0FBQ0gsVUFBVUEsSUFBSTtJQUNYQSxLQUFLQyxXQUFXLEdBQUcsQ0FBQ0MsTUFBUUE7SUFDNUIsU0FBU0MsU0FBU0MsSUFBSSxHQUFJO0lBQzFCSixLQUFLRyxRQUFRLEdBQUdBO0lBQ2hCLFNBQVNFLFlBQVlDLEVBQUU7UUFDbkIsTUFBTSxJQUFJQztJQUNkO0lBQ0FQLEtBQUtLLFdBQVcsR0FBR0E7SUFDbkJMLEtBQUtRLFdBQVcsR0FBRyxDQUFDQztRQUNoQixNQUFNQyxNQUFNLENBQUM7UUFDYixLQUFLLE1BQU1DLFFBQVFGLE1BQU87WUFDdEJDLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHQTtRQUNoQjtRQUNBLE9BQU9EO0lBQ1g7SUFDQVYsS0FBS1ksa0JBQWtCLEdBQUcsQ0FBQ0Y7UUFDdkIsTUFBTUcsWUFBWWIsS0FBS2MsVUFBVSxDQUFDSixLQUFLSyxNQUFNLENBQUMsQ0FBQ0MsSUFBTSxPQUFPTixHQUFHLENBQUNBLEdBQUcsQ0FBQ00sRUFBRSxDQUFDLEtBQUs7UUFDNUUsTUFBTUMsV0FBVyxDQUFDO1FBQ2xCLEtBQUssTUFBTUQsS0FBS0gsVUFBVztZQUN2QkksUUFBUSxDQUFDRCxFQUFFLEdBQUdOLEdBQUcsQ0FBQ00sRUFBRTtRQUN4QjtRQUNBLE9BQU9oQixLQUFLa0IsWUFBWSxDQUFDRDtJQUM3QjtJQUNBakIsS0FBS2tCLFlBQVksR0FBRyxDQUFDUjtRQUNqQixPQUFPVixLQUFLYyxVQUFVLENBQUNKLEtBQUtTLEdBQUcsQ0FBQyxTQUFVQyxDQUFDO1lBQ3ZDLE9BQU9WLEdBQUcsQ0FBQ1UsRUFBRTtRQUNqQjtJQUNKO0lBQ0FwQixL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UCxRQUFRSDtJQUNSdFYsVUFBVTZXO0lBQ1YzakIsUUFBUTZoQjtJQUNSL2pCLFFBQVE0a0I7SUFDUnNCLFVBQVVBO0lBQ1ZELFNBQVNBO0lBQ1RsWCxVQUFVNlc7SUFDVkksU0FBU0E7SUFDVGUsVUFBVWhCO0lBQ1ZyRCxZQUFZb0Q7SUFDWmxqQixTQUFTOGlCO0lBQ1RzQixRQUFROUI7SUFDUm5pQixLQUFLcWlCO0lBQ0w2QixjQUFjcEM7SUFDZDlpQixRQUFRK2hCO0lBQ1J4aEIsUUFBUThoQjtJQUNSOEMsYUFBYXZCO0lBQ2J3QixPQUFPbEM7SUFDUCxhQUFhWjtJQUNiK0MsT0FBT3RDO0lBQ1A1aEIsU0FBU3NoQjtJQUNULFFBQVFFO0lBQ1J5QixPQUFPQTtJQUNQaGpCLGNBQWNBO0lBQ2RDLGVBQWVBO0lBQ2ZLLFVBQVVBO0FBQ2Q7QUFFNHJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy96b2QvbGliL2luZGV4Lm1qcz83N2Q4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgdXRpbC5hc3NlcnRFcXVhbCA9ICh2YWwpID0+IHZhbDtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgICAgIC5tYXAoKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgJyR7dmFsfSdgIDogdmFsKSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCB8fCAob2JqZWN0VXRpbCA9IHt9KSk7XG5jb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm5hblwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJ1bmRlZmluZWRcIixcbiAgICBcIm51bGxcIixcbiAgICBcImFycmF5XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcInVua25vd25cIixcbiAgICBcInByb21pc2VcIixcbiAgICBcInZvaWRcIixcbiAgICBcIm5ldmVyXCIsXG4gICAgXCJtYXBcIixcbiAgICBcInNldFwiLFxuXSk7XG5jb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuXG5jb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIFwibm90X2Zpbml0ZVwiLFxuXSk7XG5jb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcblxuY29uc3QgZXJyb3JNYXAgPSAoaXNzdWUsIF9jdHgpID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImVuZHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseSBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5cbmxldCBvdmVycmlkZUVycm9yTWFwID0gZXJyb3JNYXA7XG5mdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XG59XG5cbmNvbnN0IG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aCwgLi4uKGlzc3VlRGF0YS5wYXRoIHx8IFtdKV07XG4gICAgY29uc3QgZnVsbElzc3VlID0ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIH07XG4gICAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5jb25zdCBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLCAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBlcnJvck1hcCA/IHVuZGVmaW5lZCA6IGVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5jb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xuY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbmNvbnN0IGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG5jb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5jb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG5jb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcblxudmFyIF9ab2RFbnVtX2NhY2hlLCBfWm9kTmF0aXZlRW51bV9jYWNoZTtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgICB9XG59XG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcbiAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNYXApXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IHJlcXVpcmVkX2Vycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2IgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBpbnZhbGlkX3R5cGVfZXJyb3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG5jbGFzcyBab2RUeXBlIHtcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5hc3luYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgXCJ+dmFsaWRhdGVcIihkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6ICEhdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0sIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdChkZWYpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJyYW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGRlZikge1xuICAgICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XG5jb25zdCBjdWlkMlJlZ2V4ID0gL15bMC05YS16XSskLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaTtcbi8vIGNvbnN0IHV1aWRSZWdleCA9XG4vLyAgIC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5jb25zdCB1dWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvaTtcbmNvbnN0IG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbmNvbnN0IGp3dFJlZ2V4ID0gL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLztcbmNvbnN0IGR1cmF0aW9uUmVnZXggPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXGQrWSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtZJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzooPzpbLStdP1xcZCtXKXwoPzpbLStdP1xcZCtbLixdXFxkK1ckKSk/KD86KD86Wy0rXT9cXGQrRCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtEJCkpPyg/OlQoPz1bXFxkKy1dKSg/Oig/OlstK10/XFxkK0gpfCg/OlstK10/XFxkK1suLF1cXGQrSCQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86Wy0rXT9cXGQrKD86Wy4sXVxcZCspP1MpPyk/PyQvO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuLy8gZmFzdGVyLCBzaW1wbGVyLCBzYWZlclxuY29uc3QgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcbmNvbnN0IGlwdjRDaWRyUmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLztcbi8vIGNvbnN0IGlwdjZSZWdleCA9XG4vLyAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKSQvO1xuY29uc3QgaXB2NkNpZHJSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC87XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODYwMzkyL2RldGVybWluZS1pZi1zdHJpbmctaXMtaW4tYmFzZTY0LXVzaW5nLWphdmFzY3JpcHRcbmNvbnN0IGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xuLy8gaHR0cHM6Ly9iYXNlNjQuZ3VydS9zdGFuZGFyZHMvYmFzZTY0dXJsXG5jb25zdCBiYXNlNjR1cmxSZWdleCA9IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLztcbi8vIHNpbXBsZVxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9YDtcbi8vIG5vIGxlYXAgeWVhciB2YWxpZGF0aW9uXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tKCgwWzEzNTc4XXwxMHwxMiktMzF8KDBbMTMtOV18MVswLTJdKS0zMHwoMFsxLTldfDFbMC0yXSktKDBbMS05XXwxXFxcXGR8MlxcXFxkKSlgO1xuLy8gd2l0aCBsZWFwIHllYXIgdmFsaWRhdGlvblxuY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5jb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKGBeJHtkYXRlUmVnZXhTb3VyY2V9JGApO1xuZnVuY3Rpb24gdGltZVJlZ2V4U291cmNlKGFyZ3MpIHtcbiAgICBsZXQgc2Vjb25kc1JlZ2V4U291cmNlID0gYFswLTVdXFxcXGRgO1xuICAgIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHNlY29uZHNSZWdleFNvdXJjZSA9IGAke3NlY29uZHNSZWdleFNvdXJjZX0oXFxcXC5cXFxcZCspP2A7XG4gICAgfVxuICAgIGNvbnN0IHNlY29uZHNRdWFudGlmaWVyID0gYXJncy5wcmVjaXNpb24gPyBcIitcIiA6IFwiP1wiOyAvLyByZXF1aXJlIHNlY29uZHMgaWYgcHJlY2lzaW9uIGlzIG5vbnplcm9cbiAgICByZXR1cm4gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkKDoke3NlY29uZHNSZWdleFNvdXJjZX0pJHtzZWNvbmRzUXVhbnRpZmllcn1gO1xufVxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxuZnVuY3Rpb24gZGF0ZXRpbWVSZWdleChhcmdzKSB7XG4gICAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xuICAgIGNvbnN0IG9wdHMgPSBbXTtcbiAgICBvcHRzLnB1c2goYXJncy5sb2NhbCA/IGBaP2AgOiBgWmApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcbiAgICByZWdleCA9IGAke3JlZ2V4fSgke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRKV1Qoand0LCBhbGcpIHtcbiAgICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJdID0gand0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCksIFwiPVwiKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGVjb2RlZC50eXAgfHwgIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1vamlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghbmFub2lkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZDIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdWxpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBqd3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGlwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGNpZHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgbG9jYWw6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICB0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxlbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYC5taW4oMSlgXG4gICAgICovXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG93ZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvVXBwZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEYXRlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XG4gICAgfVxuICAgIGdldCBpc1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbW9qaSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVTElEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0lQKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDSURSKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImNpZHJcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NHVybCgpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjR1cmxcIik7XG4gICAgfVxuICAgIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gcGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIE1hdGgucG93KDEwLCBkZWNDb3VudCk7XG59XG5jbGFzcyBab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfZmluaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5pdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhZmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSkuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIiB8fFxuICAgICAgICAgICAgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcImZpbml0ZVwiIHx8XG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJpbnRcIiB8fFxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICAgIH1cbn1cblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfZ2V0SW52YWxpZElucHV0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxufVxuWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogKHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgfVxuICAgIHN0cmljdChtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fZGVmKS5lcnJvck1hcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGlzc3VlLCBjdHgpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGN0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChfZCA9IGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhc3N0aHJvdWdoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gICAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxuICAgIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gICAgLy8gICA+ID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICAgIC4uLmRlZixcbiAgICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgIC8vICAgICAgIH0pLFxuICAgIC8vICAgICB9KSBhcyBhbnk7XG4gICAgLy8gICB9O1xuICAgIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBtZXJnZShtZXJnaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvLyBtZXJnZTxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH0sXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfVxuICAgIC8vID4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQsXG4gICAgLy8gICBOZXdJbnB1dFxuICAgIC8vID4ge1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAgIC8vIFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyA+IHtcbiAgICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgLy8gICAvLyApO1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXMobWFzaykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkZWVwUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xuICAgIH1cbiAgICBwYXJ0aWFsKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1aXJlZChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSBuZXdGaWVsZC5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5b2YoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gICAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZpcnN0IGlzc3VlLWZyZWUgdmFsaWRhdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGlzc3VlcyBmcm9tIGRpcnR5IG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IG5ldyBab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0geyByZXN1bHQsIGN0eDogY2hpbGRDdHggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlcykgPT4gbmV3IFpvZEVycm9yKGlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxufVxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgb3B0aW9uczogdHlwZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMYXp5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5pbm5lclR5cGUoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFbnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyh0eXBlLmVudW0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2NyaW1pbmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcCxcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3NcbiAgICAgICAgICAgICAgICA/IGFyZ3NcbiAgICAgICAgICAgICAgICA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9ab2RFbnVtX2NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmNsYXNzIFpvZE5hdGl2ZUVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgX1pvZE5hdGl2ZUVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5fWm9kTmF0aXZlRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiZcbiAgICAgICAgICAgIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2VcbiAgICAgICAgICAgID8gY3R4LmRhdGFcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgaW5uZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgc291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBwYXRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgucGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQ3R4LmFkZElzc3VlID0gY2hlY2tDdHguYWRkSXNzdWUuYmluZChjaGVja0N0eCk7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcbiAgICAgICAgICAgIDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5jbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5jbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBjb25zdCBmcmVlemUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNBc3luYyhyZXN1bHQpXG4gICAgICAgICAgICA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpXG4gICAgICAgICAgICA6IGZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIHouY3VzdG9tICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHBhcmFtcyhkYXRhKVxuICAgICAgICA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8geyBtZXNzYWdlOiBwYXJhbXMgfVxuICAgICAgICAgICAgOiBwYXJhbXM7XG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICByZXR1cm4gcDI7XG59XG5mdW5jdGlvbiBjdXN0b20oY2hlY2ssIF9wYXJhbXMgPSB7fSwgXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcbiAqXG4gKiBgYGB0c1xuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXG4gKiBgYGBcbiAqXG4gKi9cbmZhdGFsKSB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCByID0gY2hlY2soZGF0YSk7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbmNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG5jbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3QgY29lcmNlID0ge1xuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgbnVtYmVyOiAoKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xuICAgICAgICAuLi5hcmcsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICB9KSksXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBkYXRlOiAoKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG59O1xuY29uc3QgTkVWRVIgPSBJTlZBTElEO1xuXG52YXIgeiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZGVmYXVsdEVycm9yTWFwOiBlcnJvck1hcCxcbiAgICBzZXRFcnJvck1hcDogc2V0RXJyb3JNYXAsXG4gICAgZ2V0RXJyb3JNYXA6IGdldEVycm9yTWFwLFxuICAgIG1ha2VJc3N1ZTogbWFrZUlzc3VlLFxuICAgIEVNUFRZX1BBVEg6IEVNUFRZX1BBVEgsXG4gICAgYWRkSXNzdWVUb0NvbnRleHQ6IGFkZElzc3VlVG9Db250ZXh0LFxuICAgIFBhcnNlU3RhdHVzOiBQYXJzZVN0YXR1cyxcbiAgICBJTlZBTElEOiBJTlZBTElELFxuICAgIERJUlRZOiBESVJUWSxcbiAgICBPSzogT0ssXG4gICAgaXNBYm9ydGVkOiBpc0Fib3J0ZWQsXG4gICAgaXNEaXJ0eTogaXNEaXJ0eSxcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGlzQXN5bmM6IGlzQXN5bmMsXG4gICAgZ2V0IHV0aWwgKCkgeyByZXR1cm4gdXRpbDsgfSxcbiAgICBnZXQgb2JqZWN0VXRpbCAoKSB7IHJldHVybiBvYmplY3RVdGlsOyB9LFxuICAgIFpvZFBhcnNlZFR5cGU6IFpvZFBhcnNlZFR5cGUsXG4gICAgZ2V0UGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZSxcbiAgICBab2RUeXBlOiBab2RUeXBlLFxuICAgIGRhdGV0aW1lUmVnZXg6IGRhdGV0aW1lUmVnZXgsXG4gICAgWm9kU3RyaW5nOiBab2RTdHJpbmcsXG4gICAgWm9kTnVtYmVyOiBab2ROdW1iZXIsXG4gICAgWm9kQmlnSW50OiBab2RCaWdJbnQsXG4gICAgWm9kQm9vbGVhbjogWm9kQm9vbGVhbixcbiAgICBab2REYXRlOiBab2REYXRlLFxuICAgIFpvZFN5bWJvbDogWm9kU3ltYm9sLFxuICAgIFpvZFVuZGVmaW5lZDogWm9kVW5kZWZpbmVkLFxuICAgIFpvZE51bGw6IFpvZE51bGwsXG4gICAgWm9kQW55OiBab2RBbnksXG4gICAgWm9kVW5rbm93bjogWm9kVW5rbm93bixcbiAgICBab2ROZXZlcjogWm9kTmV2ZXIsXG4gICAgWm9kVm9pZDogWm9kVm9pZCxcbiAgICBab2RBcnJheTogWm9kQXJyYXksXG4gICAgWm9kT2JqZWN0OiBab2RPYmplY3QsXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogWm9kSW50ZXJzZWN0aW9uLFxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcbiAgICBab2RNYXA6IFpvZE1hcCxcbiAgICBab2RTZXQ6IFpvZFNldCxcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXG4gICAgWm9kTGF6eTogWm9kTGF6eSxcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxuICAgIFpvZEVudW06IFpvZEVudW0sXG4gICAgWm9kTmF0aXZlRW51bTogWm9kTmF0aXZlRW51bSxcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcbiAgICBab2REZWZhdWx0OiBab2REZWZhdWx0LFxuICAgIFpvZENhdGNoOiBab2RDYXRjaCxcbiAgICBab2ROYU46IFpvZE5hTixcbiAgICBCUkFORDogQlJBTkQsXG4gICAgWm9kQnJhbmRlZDogWm9kQnJhbmRlZCxcbiAgICBab2RQaXBlbGluZTogWm9kUGlwZWxpbmUsXG4gICAgWm9kUmVhZG9ubHk6IFpvZFJlYWRvbmx5LFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBjb2VyY2U6IGNvZXJjZSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NUeXBlLFxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxuICAgIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgICBzZXQ6IHNldFR5cGUsXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxuICAgIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIE5FVkVSOiBORVZFUixcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcbiAgICBxdW90ZWxlc3NKc29uOiBxdW90ZWxlc3NKc29uLFxuICAgIFpvZEVycm9yOiBab2RFcnJvclxufSk7XG5cbmV4cG9ydCB7IEJSQU5ELCBESVJUWSwgRU1QVFlfUEFUSCwgSU5WQUxJRCwgTkVWRVIsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kQnJhbmRlZCwgWm9kQ2F0Y2gsIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFBpcGVsaW5lLCBab2RQcm9taXNlLCBab2RSZWFkb25seSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZFN5bWJvbCwgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciwgWm9kVHVwbGUsIFpvZFR5cGUsIFpvZFVuZGVmaW5lZCwgWm9kVW5pb24sIFpvZFVua25vd24sIFpvZFZvaWQsIGFkZElzc3VlVG9Db250ZXh0LCBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgY29lcmNlLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIGRhdGV0aW1lUmVnZXgsIHogYXMgZGVmYXVsdCwgZXJyb3JNYXAgYXMgZGVmYXVsdEVycm9yTWFwLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGdldEVycm9yTWFwLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCBxdW90ZWxlc3NKc29uLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHNldEVycm9yTWFwLCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB1dGlsLCB2b2lkVHlwZSBhcyB2b2lkLCB6IH07XG4iXSwibmFtZXMiOlsidXRpbCIsImFzc2VydEVxdWFsIiwidmFsIiwiYXNzZXJ0SXMiLCJfYXJnIiwiYXNzZXJ0TmV2ZXIiLCJfeCIsIkVycm9yIiwiYXJyYXlUb0VudW0iLCJpdGVtcyIsIm9iaiIsIml0ZW0iLCJnZXRWYWxpZEVudW1WYWx1ZXMiLCJ2YWxpZEtleXMiLCJvYmplY3RLZXlzIiwiZmlsdGVyIiwiayIsImZpbHRlcmVkIiwib2JqZWN0VmFsdWVzIiwibWFwIiwiZSIsIk9iamVjdCIsImtleXMiLCJvYmplY3QiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwdXNoIiwiZmluZCIsImFyciIsImNoZWNrZXIiLCJ1bmRlZmluZWQiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hdGgiLCJmbG9vciIsImpvaW5WYWx1ZXMiLCJhcnJheSIsInNlcGFyYXRvciIsImpvaW4iLCJqc29uU3RyaW5naWZ5UmVwbGFjZXIiLCJfIiwidmFsdWUiLCJ0b1N0cmluZyIsIm9iamVjdFV0aWwiLCJtZXJnZVNoYXBlcyIsImZpcnN0Iiwic2Vjb25kIiwiWm9kUGFyc2VkVHlwZSIsImdldFBhcnNlZFR5cGUiLCJkYXRhIiwidCIsInN0cmluZyIsImlzTmFOIiwibmFuIiwibnVtYmVyIiwiYm9vbGVhbiIsImZ1bmN0aW9uIiwiYmlnaW50Iiwic3ltYm9sIiwiQXJyYXkiLCJpc0FycmF5IiwibnVsbCIsInRoZW4iLCJjYXRjaCIsInByb21pc2UiLCJNYXAiLCJTZXQiLCJzZXQiLCJEYXRlIiwiZGF0ZSIsInVua25vd24iLCJab2RJc3N1ZUNvZGUiLCJxdW90ZWxlc3NKc29uIiwianNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXBsYWNlIiwiWm9kRXJyb3IiLCJlcnJvcnMiLCJpc3N1ZXMiLCJjb25zdHJ1Y3RvciIsImFkZElzc3VlIiwic3ViIiwiYWRkSXNzdWVzIiwic3VicyIsImFjdHVhbFByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJuYW1lIiwiZm9ybWF0IiwiX21hcHBlciIsIm1hcHBlciIsImlzc3VlIiwibWVzc2FnZSIsImZpZWxkRXJyb3JzIiwiX2Vycm9ycyIsInByb2Nlc3NFcnJvciIsImVycm9yIiwiY29kZSIsInVuaW9uRXJyb3JzIiwicmV0dXJuVHlwZUVycm9yIiwiYXJndW1lbnRzRXJyb3IiLCJwYXRoIiwibGVuZ3RoIiwiY3VyciIsImkiLCJlbCIsInRlcm1pbmFsIiwiYXNzZXJ0IiwiaXNFbXB0eSIsImZsYXR0ZW4iLCJmb3JtRXJyb3JzIiwiY3JlYXRlIiwiZXJyb3JNYXAiLCJfY3R4IiwiaW52YWxpZF90eXBlIiwicmVjZWl2ZWQiLCJleHBlY3RlZCIsImludmFsaWRfbGl0ZXJhbCIsInVucmVjb2duaXplZF9rZXlzIiwiaW52YWxpZF91bmlvbiIsImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvciIsIm9wdGlvbnMiLCJpbnZhbGlkX2VudW1fdmFsdWUiLCJpbnZhbGlkX2FyZ3VtZW50cyIsImludmFsaWRfcmV0dXJuX3R5cGUiLCJpbnZhbGlkX2RhdGUiLCJpbnZhbGlkX3N0cmluZyIsInZhbGlkYXRpb24iLCJpbmNsdWRlcyIsInBvc2l0aW9uIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidG9vX3NtYWxsIiwidHlwZSIsImV4YWN0IiwiaW5jbHVzaXZlIiwibWluaW11bSIsInRvb19iaWciLCJtYXhpbXVtIiwiY3VzdG9tIiwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMiLCJub3RfbXVsdGlwbGVfb2YiLCJtdWx0aXBsZU9mIiwibm90X2Zpbml0ZSIsImRlZmF1bHRFcnJvciIsIm92ZXJyaWRlRXJyb3JNYXAiLCJzZXRFcnJvck1hcCIsImdldEVycm9yTWFwIiwibWFrZUlzc3VlIiwicGFyYW1zIiwiZXJyb3JNYXBzIiwiaXNzdWVEYXRhIiwiZnVsbFBhdGgiLCJmdWxsSXNzdWUiLCJlcnJvck1lc3NhZ2UiLCJtYXBzIiwibSIsInNsaWNlIiwicmV2ZXJzZSIsIkVNUFRZX1BBVEgiLCJhZGRJc3N1ZVRvQ29udGV4dCIsImN0eCIsIm92ZXJyaWRlTWFwIiwiY29tbW9uIiwiY29udGV4dHVhbEVycm9yTWFwIiwic2NoZW1hRXJyb3JNYXAiLCJ4IiwiUGFyc2VTdGF0dXMiLCJkaXJ0eSIsImFib3J0IiwibWVyZ2VBcnJheSIsInN0YXR1cyIsInJlc3VsdHMiLCJhcnJheVZhbHVlIiwicyIsIklOVkFMSUQiLCJtZXJnZU9iamVjdEFzeW5jIiwicGFpcnMiLCJzeW5jUGFpcnMiLCJwYWlyIiwibWVyZ2VPYmplY3RTeW5jIiwiZmluYWxPYmplY3QiLCJhbHdheXNTZXQiLCJmcmVlemUiLCJESVJUWSIsIk9LIiwiaXNBYm9ydGVkIiwiaXNEaXJ0eSIsImlzVmFsaWQiLCJpc0FzeW5jIiwiUHJvbWlzZSIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwia2luZCIsImYiLCJUeXBlRXJyb3IiLCJoYXMiLCJnZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwiU3VwcHJlc3NlZEVycm9yIiwic3VwcHJlc3NlZCIsImVycm9yVXRpbCIsImVyclRvT2JqIiwiX1pvZEVudW1fY2FjaGUiLCJfWm9kTmF0aXZlRW51bV9jYWNoZSIsIlBhcnNlSW5wdXRMYXp5UGF0aCIsInBhcmVudCIsIl9jYWNoZWRQYXRoIiwiX3BhdGgiLCJfa2V5IiwiaGFuZGxlUmVzdWx0IiwicmVzdWx0Iiwic3VjY2VzcyIsIl9lcnJvciIsInByb2Nlc3NDcmVhdGVQYXJhbXMiLCJpbnZhbGlkX3R5cGVfZXJyb3IiLCJyZXF1aXJlZF9lcnJvciIsImRlc2NyaXB0aW9uIiwiY3VzdG9tTWFwIiwiaXNzIiwiX2EiLCJfYiIsIlpvZFR5cGUiLCJfZGVmIiwiX2dldFR5cGUiLCJpbnB1dCIsIl9nZXRPclJldHVybkN0eCIsInBhcnNlZFR5cGUiLCJfcHJvY2Vzc0lucHV0UGFyYW1zIiwiX3BhcnNlU3luYyIsIl9wYXJzZSIsIl9wYXJzZUFzeW5jIiwicmVzb2x2ZSIsInBhcnNlIiwic2FmZVBhcnNlIiwiYXN5bmMiLCJlcnIiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlQXN5bmMiLCJzYWZlUGFyc2VBc3luYyIsIm1heWJlQXN5bmNSZXN1bHQiLCJyZWZpbmUiLCJjaGVjayIsImdldElzc3VlUHJvcGVydGllcyIsIl9yZWZpbmVtZW50Iiwic2V0RXJyb3IiLCJyZWZpbmVtZW50IiwicmVmaW5lbWVudERhdGEiLCJab2RFZmZlY3RzIiwic2NoZW1hIiwidHlwZU5hbWUiLCJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCJlZmZlY3QiLCJzdXBlclJlZmluZSIsImRlZiIsInNwYSIsImJpbmQiLCJvcHRpb25hbCIsIm51bGxhYmxlIiwibnVsbGlzaCIsIm9yIiwiYW5kIiwidHJhbnNmb3JtIiwiYnJhbmQiLCJkZWZhdWx0IiwiZGVzY3JpYmUiLCJwaXBlIiwicmVhZG9ubHkiLCJpc051bGxhYmxlIiwiaXNPcHRpb25hbCIsInZlcnNpb24iLCJ2ZW5kb3IiLCJ2YWxpZGF0ZSIsIlpvZE9wdGlvbmFsIiwiWm9kTnVsbGFibGUiLCJab2RBcnJheSIsIlpvZFByb21pc2UiLCJvcHRpb24iLCJab2RVbmlvbiIsImluY29taW5nIiwiWm9kSW50ZXJzZWN0aW9uIiwiZGVmYXVsdFZhbHVlRnVuYyIsIlpvZERlZmF1bHQiLCJpbm5lclR5cGUiLCJkZWZhdWx0VmFsdWUiLCJab2RCcmFuZGVkIiwiY2F0Y2hWYWx1ZUZ1bmMiLCJab2RDYXRjaCIsImNhdGNoVmFsdWUiLCJUaGlzIiwidGFyZ2V0IiwiWm9kUGlwZWxpbmUiLCJab2RSZWFkb25seSIsImN1aWRSZWdleCIsImN1aWQyUmVnZXgiLCJ1bGlkUmVnZXgiLCJ1dWlkUmVnZXgiLCJuYW5vaWRSZWdleCIsImp3dFJlZ2V4IiwiZHVyYXRpb25SZWdleCIsImVtYWlsUmVnZXgiLCJfZW1vamlSZWdleCIsImVtb2ppUmVnZXgiLCJpcHY0UmVnZXgiLCJpcHY0Q2lkclJlZ2V4IiwiaXB2NlJlZ2V4IiwiaXB2NkNpZHJSZWdleCIsImJhc2U2NFJlZ2V4IiwiYmFzZTY0dXJsUmVnZXgiLCJkYXRlUmVnZXhTb3VyY2UiLCJkYXRlUmVnZXgiLCJSZWdFeHAiLCJ0aW1lUmVnZXhTb3VyY2UiLCJhcmdzIiwic2Vjb25kc1JlZ2V4U291cmNlIiwicHJlY2lzaW9uIiwic2Vjb25kc1F1YW50aWZpZXIiLCJ0aW1lUmVnZXgiLCJkYXRldGltZVJlZ2V4IiwicmVnZXgiLCJvcHRzIiwibG9jYWwiLCJvZmZzZXQiLCJpc1ZhbGlkSVAiLCJpcCIsInRlc3QiLCJpc1ZhbGlkSldUIiwiand0IiwiYWxnIiwiaGVhZGVyIiwic3BsaXQiLCJiYXNlNjQiLCJwYWRFbmQiLCJkZWNvZGVkIiwiYXRvYiIsInR5cCIsImlzVmFsaWRDaWRyIiwiWm9kU3RyaW5nIiwiY29lcmNlIiwiU3RyaW5nIiwiY2hlY2tzIiwidG9vQmlnIiwidG9vU21hbGwiLCJVUkwiLCJsYXN0SW5kZXgiLCJ0ZXN0UmVzdWx0IiwidHJpbSIsInRvVXBwZXJDYXNlIiwiX3JlZ2V4IiwiX2FkZENoZWNrIiwiZW1haWwiLCJ1cmwiLCJlbW9qaSIsInV1aWQiLCJuYW5vaWQiLCJjdWlkIiwiY3VpZDIiLCJ1bGlkIiwiYmFzZTY0dXJsIiwiY2lkciIsImRhdGV0aW1lIiwidGltZSIsImR1cmF0aW9uIiwibWluIiwibWluTGVuZ3RoIiwibWF4IiwibWF4TGVuZ3RoIiwibGVuIiwibm9uZW1wdHkiLCJpc0RhdGV0aW1lIiwiY2giLCJpc0RhdGUiLCJpc1RpbWUiLCJpc0R1cmF0aW9uIiwiaXNFbWFpbCIsImlzVVJMIiwiaXNFbW9qaSIsImlzVVVJRCIsImlzTkFOT0lEIiwiaXNDVUlEIiwiaXNDVUlEMiIsImlzVUxJRCIsImlzSVAiLCJpc0NJRFIiLCJpc0Jhc2U2NCIsImlzQmFzZTY0dXJsIiwiZmxvYXRTYWZlUmVtYWluZGVyIiwic3RlcCIsInZhbERlY0NvdW50Iiwic3RlcERlY0NvdW50IiwiZGVjQ291bnQiLCJ2YWxJbnQiLCJwYXJzZUludCIsInRvRml4ZWQiLCJzdGVwSW50IiwicG93IiwiWm9kTnVtYmVyIiwiYXJndW1lbnRzIiwiZ3RlIiwibHRlIiwic2V0TGltaXQiLCJndCIsImx0IiwiaW50IiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsIm5vbnBvc2l0aXZlIiwibm9ubmVnYXRpdmUiLCJmaW5pdGUiLCJzYWZlIiwiTUlOX1NBRkVfSU5URUdFUiIsIk1BWF9TQUZFX0lOVEVHRVIiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiaXNJbnQiLCJab2RCaWdJbnQiLCJCaWdJbnQiLCJfZ2V0SW52YWxpZElucHV0IiwiWm9kQm9vbGVhbiIsIkJvb2xlYW4iLCJab2REYXRlIiwiZ2V0VGltZSIsIm1pbkRhdGUiLCJtYXhEYXRlIiwiWm9kU3ltYm9sIiwiWm9kVW5kZWZpbmVkIiwiWm9kTnVsbCIsIlpvZEFueSIsIl9hbnkiLCJab2RVbmtub3duIiwiX3Vua25vd24iLCJab2ROZXZlciIsIm5ldmVyIiwiWm9kVm9pZCIsInZvaWQiLCJleGFjdExlbmd0aCIsImFsbCIsImVsZW1lbnQiLCJkZWVwUGFydGlhbGlmeSIsIlpvZE9iamVjdCIsIm5ld1NoYXBlIiwic2hhcGUiLCJmaWVsZFNjaGVtYSIsInVud3JhcCIsIlpvZFR1cGxlIiwiX2NhY2hlZCIsIm5vbnN0cmljdCIsInBhc3N0aHJvdWdoIiwiYXVnbWVudCIsImV4dGVuZCIsIl9nZXRDYWNoZWQiLCJzaGFwZUtleXMiLCJleHRyYUtleXMiLCJjYXRjaGFsbCIsInVua25vd25LZXlzIiwia2V5VmFsaWRhdG9yIiwic3RyaWN0IiwiX2MiLCJfZCIsInN0cmlwIiwiYXVnbWVudGF0aW9uIiwibWVyZ2UiLCJtZXJnaW5nIiwibWVyZ2VkIiwic2V0S2V5IiwiaW5kZXgiLCJwaWNrIiwibWFzayIsImZvckVhY2giLCJvbWl0IiwiZGVlcFBhcnRpYWwiLCJwYXJ0aWFsIiwicmVxdWlyZWQiLCJuZXdGaWVsZCIsImtleW9mIiwiY3JlYXRlWm9kRW51bSIsInN0cmljdENyZWF0ZSIsImxhenljcmVhdGUiLCJoYW5kbGVSZXN1bHRzIiwiY2hpbGRDdHgiLCJ0eXBlcyIsImdldERpc2NyaW1pbmF0b3IiLCJab2RMYXp5IiwiWm9kTGl0ZXJhbCIsIlpvZEVudW0iLCJab2ROYXRpdmVFbnVtIiwiZW51bSIsIlpvZERpc2NyaW1pbmF0ZWRVbmlvbiIsImRpc2NyaW1pbmF0b3IiLCJkaXNjcmltaW5hdG9yVmFsdWUiLCJvcHRpb25zTWFwIiwiZnJvbSIsImRpc2NyaW1pbmF0b3JWYWx1ZXMiLCJtZXJnZVZhbHVlcyIsImEiLCJiIiwiYVR5cGUiLCJiVHlwZSIsInZhbGlkIiwiYktleXMiLCJzaGFyZWRLZXlzIiwiaW5kZXhPZiIsIm5ld09iaiIsInNoYXJlZFZhbHVlIiwibmV3QXJyYXkiLCJpdGVtQSIsIml0ZW1CIiwiaGFuZGxlUGFyc2VkIiwicGFyc2VkTGVmdCIsInBhcnNlZFJpZ2h0IiwibGVmdCIsInJpZ2h0IiwicmVzdCIsIml0ZW1JbmRleCIsInNjaGVtYXMiLCJab2RSZWNvcmQiLCJrZXlTY2hlbWEiLCJrZXlUeXBlIiwidmFsdWVTY2hlbWEiLCJ2YWx1ZVR5cGUiLCJ0aGlyZCIsIlpvZE1hcCIsImVudHJpZXMiLCJmaW5hbE1hcCIsIlpvZFNldCIsIm1pblNpemUiLCJzaXplIiwibWF4U2l6ZSIsImZpbmFsaXplU2V0IiwiZWxlbWVudHMiLCJwYXJzZWRTZXQiLCJhZGQiLCJ2YWx1ZXMiLCJab2RGdW5jdGlvbiIsImltcGxlbWVudCIsIm1ha2VBcmdzSXNzdWUiLCJtYWtlUmV0dXJuc0lzc3VlIiwicmV0dXJucyIsImZuIiwibWUiLCJwYXJzZWRBcmdzIiwiUmVmbGVjdCIsImFwcGx5IiwicGFyc2VkUmV0dXJucyIsInBhcmFtZXRlcnMiLCJyZXR1cm5UeXBlIiwiZnVuYyIsInZhbGlkYXRlZEZ1bmMiLCJzdHJpY3RJbXBsZW1lbnQiLCJnZXR0ZXIiLCJsYXp5U2NoZW1hIiwiZXhwZWN0ZWRWYWx1ZXMiLCJlbnVtVmFsdWVzIiwiVmFsdWVzIiwiRW51bSIsImV4dHJhY3QiLCJuZXdEZWYiLCJleGNsdWRlIiwib3B0IiwiV2Vha01hcCIsIm5hdGl2ZUVudW1WYWx1ZXMiLCJwcm9taXNpZmllZCIsInNvdXJjZVR5cGUiLCJjaGVja0N0eCIsImFyZyIsImZhdGFsIiwicHJvY2Vzc2VkIiwiZXhlY3V0ZVJlZmluZW1lbnQiLCJhY2MiLCJpbm5lciIsImJhc2UiLCJjcmVhdGVXaXRoUHJlcHJvY2VzcyIsInByZXByb2Nlc3MiLCJyZW1vdmVEZWZhdWx0IiwibmV3Q3R4IiwicmVtb3ZlQ2F0Y2giLCJab2ROYU4iLCJCUkFORCIsIlN5bWJvbCIsImhhbmRsZUFzeW5jIiwiaW5SZXN1bHQiLCJpbiIsIm91dCIsImNsZWFuUGFyYW1zIiwicCIsInAyIiwiX3BhcmFtcyIsInIiLCJfZmF0YWwiLCJsYXRlIiwiaW5zdGFuY2VPZlR5cGUiLCJjbHMiLCJzdHJpbmdUeXBlIiwibnVtYmVyVHlwZSIsIm5hblR5cGUiLCJiaWdJbnRUeXBlIiwiYm9vbGVhblR5cGUiLCJkYXRlVHlwZSIsInN5bWJvbFR5cGUiLCJ1bmRlZmluZWRUeXBlIiwibnVsbFR5cGUiLCJhbnlUeXBlIiwidW5rbm93blR5cGUiLCJuZXZlclR5cGUiLCJ2b2lkVHlwZSIsImFycmF5VHlwZSIsIm9iamVjdFR5cGUiLCJzdHJpY3RPYmplY3RUeXBlIiwidW5pb25UeXBlIiwiZGlzY3JpbWluYXRlZFVuaW9uVHlwZSIsImludGVyc2VjdGlvblR5cGUiLCJ0dXBsZVR5cGUiLCJyZWNvcmRUeXBlIiwibWFwVHlwZSIsInNldFR5cGUiLCJmdW5jdGlvblR5cGUiLCJsYXp5VHlwZSIsImxpdGVyYWxUeXBlIiwiZW51bVR5cGUiLCJuYXRpdmVFbnVtVHlwZSIsInByb21pc2VUeXBlIiwiZWZmZWN0c1R5cGUiLCJvcHRpb25hbFR5cGUiLCJudWxsYWJsZVR5cGUiLCJwcmVwcm9jZXNzVHlwZSIsInBpcGVsaW5lVHlwZSIsIm9zdHJpbmciLCJvbnVtYmVyIiwib2Jvb2xlYW4iLCJORVZFUiIsInoiLCJkZWZhdWx0RXJyb3JNYXAiLCJab2RUcmFuc2Zvcm1lciIsIlNjaGVtYSIsIlpvZFNjaGVtYSIsImFueSIsImRpc2NyaW1pbmF0ZWRVbmlvbiIsImludGVyc2VjdGlvbiIsImxhenkiLCJsaXRlcmFsIiwibmF0aXZlRW51bSIsInBpcGVsaW5lIiwicmVjb3JkIiwic3RyaWN0T2JqZWN0IiwidHJhbnNmb3JtZXIiLCJ0dXBsZSIsInVuaW9uIiwiaW5zdGFuY2VvZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zod/lib/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: () => (/* binding */ BRAND),\n/* harmony export */   DIRTY: () => (/* binding */ DIRTY),\n/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),\n/* harmony export */   INVALID: () => (/* binding */ INVALID),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   OK: () => (/* binding */ OK),\n/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),\n/* harmony export */   Schema: () => (/* binding */ ZodType),\n/* harmony export */   ZodAny: () => (/* binding */ ZodAny),\n/* harmony export */   ZodArray: () => (/* binding */ ZodArray),\n/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),\n/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),\n/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),\n/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),\n/* harmony export */   ZodDate: () => (/* binding */ ZodDate),\n/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),\n/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),\n/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),\n/* harmony export */   ZodError: () => (/* binding */ ZodError),\n/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),\n/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),\n/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),\n/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),\n/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),\n/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),\n/* harmony export */   ZodMap: () => (/* binding */ ZodMap),\n/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),\n/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),\n/* harmony export */   ZodNever: () => (/* binding */ ZodNever),\n/* harmony export */   ZodNull: () => (/* binding */ ZodNull),\n/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),\n/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),\n/* harmony export */   ZodObject: () => (/* binding */ ZodObject),\n/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),\n/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),\n/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),\n/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),\n/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),\n/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),\n/* harmony export */   ZodSchema: () => (/* binding */ ZodType),\n/* harmony export */   ZodSet: () => (/* binding */ ZodSet),\n/* harmony export */   ZodString: () => (/* binding */ ZodString),\n/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),\n/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),\n/* harmony export */   ZodType: () => (/* binding */ ZodType),\n/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),\n/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),\n/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),\n/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),\n/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),\n/* harmony export */   any: () => (/* binding */ anyType),\n/* harmony export */   array: () => (/* binding */ arrayType),\n/* harmony export */   bigint: () => (/* binding */ bigIntType),\n/* harmony export */   boolean: () => (/* binding */ booleanType),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   date: () => (/* binding */ dateType),\n/* harmony export */   datetimeRegex: () => (/* binding */ datetimeRegex),\n/* harmony export */   \"default\": () => (/* binding */ z),\n/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),\n/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),\n/* harmony export */   effect: () => (/* binding */ effectsType),\n/* harmony export */   \"enum\": () => (/* binding */ enumType),\n/* harmony export */   \"function\": () => (/* binding */ functionType),\n/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),\n/* harmony export */   getParsedType: () => (/* binding */ getParsedType),\n/* harmony export */   \"instanceof\": () => (/* binding */ instanceOfType),\n/* harmony export */   intersection: () => (/* binding */ intersectionType),\n/* harmony export */   isAborted: () => (/* binding */ isAborted),\n/* harmony export */   isAsync: () => (/* binding */ isAsync),\n/* harmony export */   isDirty: () => (/* binding */ isDirty),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   late: () => (/* binding */ late),\n/* harmony export */   lazy: () => (/* binding */ lazyType),\n/* harmony export */   literal: () => (/* binding */ literalType),\n/* harmony export */   makeIssue: () => (/* binding */ makeIssue),\n/* harmony export */   map: () => (/* binding */ mapType),\n/* harmony export */   nan: () => (/* binding */ nanType),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),\n/* harmony export */   never: () => (/* binding */ neverType),\n/* harmony export */   \"null\": () => (/* binding */ nullType),\n/* harmony export */   nullable: () => (/* binding */ nullableType),\n/* harmony export */   number: () => (/* binding */ numberType),\n/* harmony export */   object: () => (/* binding */ objectType),\n/* harmony export */   objectUtil: () => (/* binding */ objectUtil),\n/* harmony export */   oboolean: () => (/* binding */ oboolean),\n/* harmony export */   onumber: () => (/* binding */ onumber),\n/* harmony export */   optional: () => (/* binding */ optionalType),\n/* harmony export */   ostring: () => (/* binding */ ostring),\n/* harmony export */   pipeline: () => (/* binding */ pipelineType),\n/* harmony export */   preprocess: () => (/* binding */ preprocessType),\n/* harmony export */   promise: () => (/* binding */ promiseType),\n/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),\n/* harmony export */   record: () => (/* binding */ recordType),\n/* harmony export */   set: () => (/* binding */ setType),\n/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),\n/* harmony export */   strictObject: () => (/* binding */ strictObjectType),\n/* harmony export */   string: () => (/* binding */ stringType),\n/* harmony export */   symbol: () => (/* binding */ symbolType),\n/* harmony export */   transformer: () => (/* binding */ effectsType),\n/* harmony export */   tuple: () => (/* binding */ tupleType),\n/* harmony export */   undefined: () => (/* binding */ undefinedType),\n/* harmony export */   union: () => (/* binding */ unionType),\n/* harmony export */   unknown: () => (/* binding */ unknownType),\n/* harmony export */   util: () => (/* binding */ util),\n/* harmony export */   \"void\": () => (/* binding */ voidType),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\nvar util;\n(function(util) {\n    util.assertEqual = (val)=>val;\n    function assertIs(_arg) {}\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items)=>{\n        const obj = {};\n        for (const item of items){\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj)=>{\n        const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys){\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj)=>{\n        return util.objectKeys(obj).map(function(e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n     ? (obj)=>Object.keys(obj) // eslint-disable-line ban/ban\n     : (object)=>{\n        const keys = [];\n        for(const key in object){\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    util.find = (arr, checker)=>{\n        for (const item of arr){\n            if (checker(item)) return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\" ? (val)=>Number.isInteger(val) // eslint-disable-line ban/ban\n     : (val)=>typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val)=>typeof val === \"string\" ? `'${val}'` : val).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value)=>{\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil) {\n    objectUtil.mergeShapes = (first, second)=>{\n        return {\n            ...first,\n            ...second\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\"\n]);\nconst getParsedType = (data)=>{\n    const t = typeof data;\n    switch(t){\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\"\n]);\nconst quotelessJson = (obj)=>{\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues){\n        super();\n        this.issues = [];\n        this.addIssue = (sub)=>{\n            this.issues = [\n                ...this.issues,\n                sub\n            ];\n        };\n        this.addIssues = (subs = [])=>{\n            this.issues = [\n                ...this.issues,\n                ...subs\n            ];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        } else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper || function(issue) {\n            return issue.message;\n        };\n        const fieldErrors = {\n            _errors: []\n        };\n        const processError = (error)=>{\n            for (const issue of error.issues){\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                } else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                } else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                } else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                } else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while(i < issue.path.length){\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                        // if (typeof el === \"string\") {\n                        //   curr[el] = curr[el] || { _errors: [] };\n                        // } else if (typeof el === \"number\") {\n                        //   const errorArray: any = [];\n                        //   errorArray._errors = [];\n                        //   curr[el] = curr[el] || errorArray;\n                        // }\n                        } else {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue)=>issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues){\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            } else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return {\n            formErrors,\n            fieldErrors\n        };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues)=>{\n    const error = new ZodError(issues);\n    return error;\n};\nconst errorMap = (issue, _ctx)=>{\n    let message;\n    switch(issue.code){\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            } else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                } else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                } else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                } else {\n                    util.assertNever(issue.validation);\n                }\n            } else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            } else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\") message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\") message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return {\n        message\n    };\n};\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\nconst makeIssue = (params)=>{\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [\n        ...path,\n        ...issueData.path || []\n    ];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps.filter((m)=>!!m).slice().reverse();\n    for (const map of maps){\n        errorMessage = map(fullIssue, {\n            data,\n            defaultError: errorMessage\n        }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            overrideMap,\n            overrideMap === errorMap ? undefined : errorMap\n        ].filter((x)=>!!x)\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor(){\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\") this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\") this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results){\n            if (s.status === \"aborted\") return INVALID;\n            if (s.status === \"dirty\") status.dirty();\n            arrayValue.push(s.value);\n        }\n        return {\n            status: status.value,\n            value: arrayValue\n        };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs){\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs){\n            const { key, value } = pair;\n            if (key.status === \"aborted\") return INVALID;\n            if (value.status === \"aborted\") return INVALID;\n            if (key.status === \"dirty\") status.dirty();\n            if (value.status === \"dirty\") status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return {\n            status: status.value,\n            value: finalObject\n        };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\"\n});\nconst DIRTY = (value)=>({\n        status: \"dirty\",\n        value\n    });\nconst OK = (value)=>({\n        status: \"valid\",\n        value\n    });\nconst isAborted = (x)=>x.status === \"aborted\";\nconst isDirty = (x)=>x.status === \"dirty\";\nconst isValid = (x)=>x.status === \"valid\";\nconst isAsync = (x)=>typeof Promise !== \"undefined\" && x instanceof Promise;\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar errorUtil;\n(function(errorUtil) {\n    errorUtil.errToObj = (message)=>typeof message === \"string\" ? {\n            message\n        } : message || {};\n    errorUtil.toString = (message)=>typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nvar _ZodEnum_cache, _ZodNativeEnum_cache;\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key){\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            } else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result)=>{\n    if (isValid(result)) {\n        return {\n            success: true,\n            data: result.value\n        };\n    } else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error () {\n                if (this._error) return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            }\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params) return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap) return {\n        errorMap: errorMap,\n        description\n    };\n    const customMap = (iss, ctx)=>{\n        var _a, _b;\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return {\n                message: message !== null && message !== void 0 ? message : ctx.defaultError\n            };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return {\n                message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError\n            };\n        }\n        if (iss.code !== \"invalid_type\") return {\n            message: ctx.defaultError\n        };\n        return {\n            message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError\n        };\n    };\n    return {\n        errorMap: customMap,\n        description\n    };\n}\nclass ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent\n        };\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent\n            }\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const result = this._parseSync({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        var _a, _b;\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({\n                    data,\n                    path: [],\n                    parent: ctx\n                });\n                return isValid(result) ? {\n                    value: result.value\n                } : {\n                    issues: ctx.common.issues\n                };\n            } catch (err) {\n                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true\n                };\n            }\n        }\n        return this._parseAsync({\n            data,\n            path: [],\n            parent: ctx\n        }).then((result)=>isValid(result) ? {\n                value: result.value\n            } : {\n                issues: ctx.common.issues\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const maybeAsyncResult = this._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val)=>{\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return {\n                    message\n                };\n            } else if (typeof message === \"function\") {\n                return message(val);\n            } else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx)=>{\n            const result = check(val);\n            const setError = ()=>ctx.addIssue({\n                    code: ZodIssueCode.custom,\n                    ...getIssueProperties(val)\n                });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data)=>{\n                    if (!data) {\n                        setError();\n                        return false;\n                    } else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx)=>{\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"refinement\",\n                refinement\n            }\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def){\n        /** Alias of safeParseAsync */ this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data)=>this[\"~validate\"](data)\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([\n            this,\n            option\n        ], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"transform\",\n                transform\n            }\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def)\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    } else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nfunction datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset) opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt)) return false;\n    try {\n        const [header] = jwt.split(\".\");\n        // Convert base64url to base64\n        const base64 = header.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(header.length + (4 - header.length % 4) % 4, \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null) return false;\n        if (!decoded.typ || !decoded.alg) return false;\n        if (alg && decoded.alg !== alg) return false;\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    } else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    }\n                    status.dirty();\n                }\n            } else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                } catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            } else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            includes: check.value,\n                            position: check.position\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            } else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            } else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            startsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            endsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data)=>regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    email(message) {\n        return this._addCheck({\n            kind: \"email\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    url(message) {\n        return this._addCheck({\n            kind: \"url\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    emoji(message) {\n        return this._addCheck({\n            kind: \"emoji\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    uuid(message) {\n        return this._addCheck({\n            kind: \"uuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    nanoid(message) {\n        return this._addCheck({\n            kind: \"nanoid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid(message) {\n        return this._addCheck({\n            kind: \"cuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid2(message) {\n        return this._addCheck({\n            kind: \"cuid2\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    ulid(message) {\n        return this._addCheck({\n            kind: \"ulid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    base64(message) {\n        return this._addCheck({\n            kind: \"base64\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    jwt(options) {\n        return this._addCheck({\n            kind: \"jwt\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    ip(options) {\n        return this._addCheck({\n            kind: \"ip\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    cidr(options) {\n        return this._addCheck({\n            kind: \"cidr\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    datetime(options) {\n        var _a, _b;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    date(message) {\n        return this._addCheck({\n            kind: \"date\",\n            message\n        });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    duration(message) {\n        return this._addCheck({\n            kind: \"duration\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */ nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"trim\"\n                }\n            ]\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toLowerCase\"\n                }\n            ]\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toUpperCase\"\n                }\n            ]\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch)=>ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params)=>{\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return valInt % stepInt / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message)\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message)\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message)\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            } else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            } else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params)=>{\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            } catch (_a) {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params)=>{\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params)=>{\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime())\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params)=>{\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params)\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params)=>{\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params)=>{\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params)=>{\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params)\n    });\n};\nclass ZodAny extends ZodType {\n    constructor(){\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params)=>{\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor(){\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params)=>{\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params)=>{\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params)\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params)=>{\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params)\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: tooSmall ? def.exactLength.value : undefined,\n                    maximum: tooBig ? def.exactLength.value : undefined,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([\n                ...ctx.data\n            ].map((item, i)=>{\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result)=>{\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [\n            ...ctx.data\n        ].map((item, i)=>{\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: {\n                value: minLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: {\n                value: maxLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: {\n                value: len,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params)=>{\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params)\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for(const key in schema.shape){\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: ()=>newShape\n        });\n    } else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element)\n        });\n    } else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));\n    } else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor(){\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */ this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */ this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null) return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return this._cached = {\n            shape,\n            keys\n        };\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for(const key in ctx.data){\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys){\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: {\n                    status: \"valid\",\n                    value: key\n                },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys){\n                    pairs.push({\n                        key: {\n                            status: \"valid\",\n                            value: key\n                        },\n                        value: {\n                            status: \"valid\",\n                            value: ctx.data[key]\n                        }\n                    });\n                }\n            } else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys\n                    });\n                    status.dirty();\n                }\n            } else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        } else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys){\n                const value = ctx.data[key];\n                pairs.push({\n                    key: {\n                        status: \"valid\",\n                        value: key\n                    },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve().then(async ()=>{\n                const syncPairs = [];\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet\n                    });\n                }\n                return syncPairs;\n            }).then((syncPairs)=>{\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...message !== undefined ? {\n                errorMap: (issue, ctx)=>{\n                    var _a, _b, _c, _d;\n                    const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                    if (issue.code === \"unrecognized_keys\") return {\n                        message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\n                    };\n                    return {\n                        message: defaultError\n                    };\n                }\n            } : {}\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\"\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\"\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...augmentation\n                })\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */ merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...merging._def.shape()\n                }),\n            typeName: ZodFirstPartyTypeKind.ZodObject\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({\n            [key]: schema\n        });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key)=>{\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    /**\n     * @deprecated\n     */ deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            } else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            } else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while(newField instanceof ZodOptional){\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.strictCreate = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.lazycreate = (shape, params)=>{\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results){\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results){\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option)=>{\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx\n                    }),\n                    ctx: childCtx\n                };\n            })).then(handleResults);\n        } else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options){\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                } else if (result.status === \"dirty\" && !dirty) {\n                    dirty = {\n                        result,\n                        ctx: childCtx\n                    };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues)=>new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params)=>{\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params)\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type)=>{\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    } else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    } else if (type instanceof ZodLiteral) {\n        return [\n            type.value\n        ];\n    } else if (type instanceof ZodEnum) {\n        return type.options;\n    } else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    } else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    } else if (type instanceof ZodUndefined) {\n        return [\n            undefined\n        ];\n    } else if (type instanceof ZodNull) {\n        return [\n            null\n        ];\n    } else if (type instanceof ZodOptional) {\n        return [\n            undefined,\n            ...getDiscriminator(type.unwrap())\n        ];\n    } else if (type instanceof ZodNullable) {\n        return [\n            null,\n            ...getDiscriminator(type.unwrap())\n        ];\n    } else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    } else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    } else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    } else {\n        return [];\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [\n                    discriminator\n                ]\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        } else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */ static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options){\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues){\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params)\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);\n        const newObj = {\n            ...a,\n            ...b\n        };\n        for (const key of sharedKeys){\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return {\n            valid: true,\n            data: newObj\n        };\n    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return {\n                valid: false\n            };\n        }\n        const newArray = [];\n        for(let index = 0; index < a.length; index++){\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return {\n            valid: true,\n            data: newArray\n        };\n    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else {\n        return {\n            valid: false\n        };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight)=>{\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return {\n                status: status.value,\n                value: merged.data\n            };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                })\n            ]).then(([left, right])=>handleParsed(left, right));\n        } else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params)=>{\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params)\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            status.dirty();\n        }\n        const items = [\n            ...ctx.data\n        ].map((item, itemIndex)=>{\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema) return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        }).filter((x)=>!!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results)=>{\n                return ParseStatus.mergeArray(status, results);\n            });\n        } else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest\n        });\n    }\n}\nZodTuple.create = (schemas, params)=>{\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params)\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for(const key in ctx.data){\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third)\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second)\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [\n            ...ctx.data.entries()\n        ].map(([key, value], index)=>{\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [\n                    index,\n                    \"key\"\n                ])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [\n                    index,\n                    \"value\"\n                ]))\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async ()=>{\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return {\n                    status: status.value,\n                    value: finalMap\n                };\n            });\n        } else {\n            const finalMap = new Map();\n            for (const pair of pairs){\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return {\n                status: status.value,\n                value: finalMap\n            };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params)=>{\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params)\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements){\n                if (element.status === \"aborted\") return INVALID;\n                if (element.status === \"dirty\") status.dirty();\n                parsedSet.add(element.value);\n            }\n            return {\n                status: status.value,\n                value: parsedSet\n            };\n        }\n        const elements = [\n            ...ctx.data.values()\n        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements)=>finalizeSet(elements));\n        } else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: {\n                value: minSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: {\n                value: maxSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params)=>{\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params)\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error\n                }\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error\n                }\n            });\n        }\n        const params = {\n            errorMap: ctx.common.contextualErrorMap\n        };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function(...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        } else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function(...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([\n                        makeArgsIssue(args, parsedArgs.error)\n                    ]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([\n                        makeReturnsIssue(result, parsedReturns.error)\n                    ]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create())\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params)\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n}\nZodLazy.create = (getter, params)=>{\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params)\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params)=>{\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params)\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params)\n    });\n}\nclass ZodEnum extends ZodType {\n    constructor(){\n        super(...arguments);\n        _ZodEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {\n            ...this._def,\n            ...newDef\n        });\n    }\n}\n_ZodEnum_cache = new WeakMap();\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    constructor(){\n        super(...arguments);\n        _ZodNativeEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\n_ZodNativeEnum_cache = new WeakMap();\nZodNativeEnum.create = (values, params)=>{\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params)\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data)=>{\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params)=>{\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params)\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg)=>{\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                } else {\n                    status.dirty();\n                }\n            },\n            get path () {\n                return ctx.path;\n            }\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed)=>{\n                    if (status.value === \"aborted\") return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                    if (result.status === \"aborted\") return INVALID;\n                    if (result.status === \"dirty\") return DIRTY(result.value);\n                    if (status.value === \"dirty\") return DIRTY(result.value);\n                    return result;\n                });\n            } else {\n                if (status.value === \"aborted\") return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (result.status === \"aborted\") return INVALID;\n                if (result.status === \"dirty\") return DIRTY(result.value);\n                if (status.value === \"dirty\") return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc)=>{\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inner.status === \"aborted\") return INVALID;\n                if (inner.status === \"dirty\") status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return {\n                    status: status.value,\n                    value: inner.value\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((inner)=>{\n                    if (inner.status === \"aborted\") return INVALID;\n                    if (inner.status === \"dirty\") status.dirty();\n                    return executeRefinement(inner.value).then(()=>{\n                        return {\n                            status: status.value,\n                            value: inner.value\n                        };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (!isValid(base)) return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return {\n                    status: status.value,\n                    value: result\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((base)=>{\n                    if (!isValid(base)) return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({\n                            status: status.value,\n                            value: result\n                        }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params)=>{\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params)\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params)=>{\n    return new ZodEffects({\n        schema,\n        effect: {\n            type: \"preprocess\",\n            transform: preprocess\n        },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params)\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params)=>{\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params)=>{\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params)\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params)=>{\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : ()=>params.default,\n        ...processCreateParams(params)\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: []\n            }\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx\n            }\n        });\n        if (isAsync(result)) {\n            return result.then((result)=>{\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\" ? result.value : this._def.catchValue({\n                        get error () {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data\n                    })\n                };\n            });\n        } else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\" ? result.value : this._def.catchValue({\n                    get error () {\n                        return new ZodError(newCtx.common.issues);\n                    },\n                    input: newCtx.data\n                })\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params)=>{\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : ()=>params.catch,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n}\nZodNaN.create = (params)=>{\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params)\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async ()=>{\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inResult.status === \"aborted\") return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                } else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                }\n            };\n            return handleAsync();\n        } else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n            if (inResult.status === \"aborted\") return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value\n                };\n            } else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data)=>{\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params)=>{\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params)\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? {\n        message: params\n    } : params;\n    const p2 = typeof p === \"string\" ? {\n        message: p\n    } : p;\n    return p2;\n}\nfunction custom(check, _params = {}, /**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */ fatal) {\n    if (check) return ZodAny.create().superRefine((data, ctx)=>{\n        var _a, _b;\n        const r = check(data);\n        if (r instanceof Promise) {\n            return r.then((r)=>{\n                var _a, _b;\n                if (!r) {\n                    const params = cleanParams(_params, data);\n                    const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                    ctx.addIssue({\n                        code: \"custom\",\n                        ...params,\n                        fatal: _fatal\n                    });\n                }\n            });\n        }\n        if (!r) {\n            const params = cleanParams(_params, data);\n            const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n            ctx.addIssue({\n                code: \"custom\",\n                ...params,\n                fatal: _fatal\n            });\n        }\n        return;\n    });\n    return ZodAny.create();\n}\nconst late = {\n    object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`\n})=>custom((data)=>data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = ()=>stringType().optional();\nconst onumber = ()=>numberType().optional();\nconst oboolean = ()=>booleanType().optional();\nconst coerce = {\n    string: (arg)=>ZodString.create({\n            ...arg,\n            coerce: true\n        }),\n    number: (arg)=>ZodNumber.create({\n            ...arg,\n            coerce: true\n        }),\n    boolean: (arg)=>ZodBoolean.create({\n            ...arg,\n            coerce: true\n        }),\n    bigint: (arg)=>ZodBigInt.create({\n            ...arg,\n            coerce: true\n        }),\n    date: (arg)=>ZodDate.create({\n            ...arg,\n            coerce: true\n        })\n};\nconst NEVER = INVALID;\nvar z = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () {\n        return util;\n    },\n    get objectUtil () {\n        return objectUtil;\n    },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    datetimeRegex: datetimeRegex,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () {\n        return ZodFirstPartyTypeKind;\n    },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    \"enum\": enumType,\n    \"function\": functionType,\n    \"instanceof\": instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    \"null\": nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    \"undefined\": undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    \"void\": voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBO0FBQ0gsVUFBVUEsSUFBSTtJQUNYQSxLQUFLQyxXQUFXLEdBQUcsQ0FBQ0MsTUFBUUE7SUFDNUIsU0FBU0MsU0FBU0MsSUFBSSxHQUFJO0lBQzFCSixLQUFLRyxRQUFRLEdBQUdBO0lBQ2hCLFNBQVNFLFlBQVlDLEVBQUU7UUFDbkIsTUFBTSxJQUFJQztJQUNkO0lBQ0FQLEtBQUtLLFdBQVcsR0FBR0E7SUFDbkJMLEtBQUtRLFdBQVcsR0FBRyxDQUFDQztRQUNoQixNQUFNQyxNQUFNLENBQUM7UUFDYixLQUFLLE1BQU1DLFFBQVFGLE1BQU87WUFDdEJDLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHQTtRQUNoQjtRQUNBLE9BQU9EO0lBQ1g7SUFDQVYsS0FBS1ksa0JBQWtCLEdBQUcsQ0FBQ0Y7UUFDdkIsTUFBTUcsWUFBWWIsS0FBS2MsVUFBVSxDQUFDSixLQUFLSyxNQUFNLENBQUMsQ0FBQ0MsSUFBTSxPQUFPTixHQUFHLENBQUNBLEdBQUcsQ0FBQ00sRUFBRSxDQUFDLEtBQUs7UUFDNUUsTUFBTUMsV0FBVyxDQUFDO1FBQ2xCLEtBQUssTUFBTUQsS0FBS0gsVUFBVztZQUN2QkksUUFBUSxDQUFDRCxFQUFFLEdBQUdOLEdBQUcsQ0FBQ00sRUFBRTtRQUN4QjtRQUNBLE9BQU9oQixLQUFLa0IsWUFBWSxDQUFDRDtJQUM3QjtJQUNBakIsS0FBS2tCLFlBQVksR0FBRyxDQUFDUjtRQUNqQixPQUFPVixLQUFLYyxVQUFVLENBQUNKLEtBQUtTLEdBQUcsQ0FBQyxTQUFVQyxDQUFDO1lBQ3ZDLE9BQU9WLEdBQUcsQ0FBQ1UsRUFBRTtRQUNqQjtJQUNKO0lBQ0FwQixL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UCxRQUFRSDtJQUNSdFYsVUFBVTZXO0lBQ1YzakIsUUFBUTZoQjtJQUNSL2pCLFFBQVE0a0I7SUFDUnNCLFVBQVVBO0lBQ1ZELFNBQVNBO0lBQ1RsWCxVQUFVNlc7SUFDVkksU0FBU0E7SUFDVGUsVUFBVWhCO0lBQ1ZyRCxZQUFZb0Q7SUFDWmxqQixTQUFTOGlCO0lBQ1RzQixRQUFROUI7SUFDUm5pQixLQUFLcWlCO0lBQ0w2QixjQUFjcEM7SUFDZDlpQixRQUFRK2hCO0lBQ1J4aEIsUUFBUThoQjtJQUNSOEMsYUFBYXZCO0lBQ2J3QixPQUFPbEM7SUFDUCxhQUFhWjtJQUNiK0MsT0FBT3RDO0lBQ1A1aEIsU0FBU3NoQjtJQUNULFFBQVFFO0lBQ1J5QixPQUFPQTtJQUNQaGpCLGNBQWNBO0lBQ2RDLGVBQWVBO0lBQ2ZLLFVBQVVBO0FBQ2Q7QUFFNHJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy96b2QvbGliL2luZGV4Lm1qcz83N2Q4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgdXRpbC5hc3NlcnRFcXVhbCA9ICh2YWwpID0+IHZhbDtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgICAgIC5tYXAoKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgJyR7dmFsfSdgIDogdmFsKSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCB8fCAob2JqZWN0VXRpbCA9IHt9KSk7XG5jb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm5hblwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJ1bmRlZmluZWRcIixcbiAgICBcIm51bGxcIixcbiAgICBcImFycmF5XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcInVua25vd25cIixcbiAgICBcInByb21pc2VcIixcbiAgICBcInZvaWRcIixcbiAgICBcIm5ldmVyXCIsXG4gICAgXCJtYXBcIixcbiAgICBcInNldFwiLFxuXSk7XG5jb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuXG5jb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIFwibm90X2Zpbml0ZVwiLFxuXSk7XG5jb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcblxuY29uc3QgZXJyb3JNYXAgPSAoaXNzdWUsIF9jdHgpID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImVuZHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseSBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5cbmxldCBvdmVycmlkZUVycm9yTWFwID0gZXJyb3JNYXA7XG5mdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XG59XG5cbmNvbnN0IG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aCwgLi4uKGlzc3VlRGF0YS5wYXRoIHx8IFtdKV07XG4gICAgY29uc3QgZnVsbElzc3VlID0ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIH07XG4gICAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5jb25zdCBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLCAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBlcnJvck1hcCA/IHVuZGVmaW5lZCA6IGVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5jb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xuY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbmNvbnN0IGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG5jb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5jb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG5jb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcblxudmFyIF9ab2RFbnVtX2NhY2hlLCBfWm9kTmF0aXZlRW51bV9jYWNoZTtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgICB9XG59XG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcbiAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNYXApXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IHJlcXVpcmVkX2Vycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2IgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBpbnZhbGlkX3R5cGVfZXJyb3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG5jbGFzcyBab2RUeXBlIHtcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5hc3luYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgXCJ+dmFsaWRhdGVcIihkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6ICEhdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0sIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdChkZWYpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJyYW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGRlZikge1xuICAgICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XG5jb25zdCBjdWlkMlJlZ2V4ID0gL15bMC05YS16XSskLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaTtcbi8vIGNvbnN0IHV1aWRSZWdleCA9XG4vLyAgIC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5jb25zdCB1dWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvaTtcbmNvbnN0IG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbmNvbnN0IGp3dFJlZ2V4ID0gL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLztcbmNvbnN0IGR1cmF0aW9uUmVnZXggPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXGQrWSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtZJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzooPzpbLStdP1xcZCtXKXwoPzpbLStdP1xcZCtbLixdXFxkK1ckKSk/KD86KD86Wy0rXT9cXGQrRCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtEJCkpPyg/OlQoPz1bXFxkKy1dKSg/Oig/OlstK10/XFxkK0gpfCg/OlstK10/XFxkK1suLF1cXGQrSCQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86Wy0rXT9cXGQrKD86Wy4sXVxcZCspP1MpPyk/PyQvO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuLy8gZmFzdGVyLCBzaW1wbGVyLCBzYWZlclxuY29uc3QgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcbmNvbnN0IGlwdjRDaWRyUmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLztcbi8vIGNvbnN0IGlwdjZSZWdleCA9XG4vLyAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKSQvO1xuY29uc3QgaXB2NkNpZHJSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC87XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODYwMzkyL2RldGVybWluZS1pZi1zdHJpbmctaXMtaW4tYmFzZTY0LXVzaW5nLWphdmFzY3JpcHRcbmNvbnN0IGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xuLy8gaHR0cHM6Ly9iYXNlNjQuZ3VydS9zdGFuZGFyZHMvYmFzZTY0dXJsXG5jb25zdCBiYXNlNjR1cmxSZWdleCA9IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLztcbi8vIHNpbXBsZVxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9YDtcbi8vIG5vIGxlYXAgeWVhciB2YWxpZGF0aW9uXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tKCgwWzEzNTc4XXwxMHwxMiktMzF8KDBbMTMtOV18MVswLTJdKS0zMHwoMFsxLTldfDFbMC0yXSktKDBbMS05XXwxXFxcXGR8MlxcXFxkKSlgO1xuLy8gd2l0aCBsZWFwIHllYXIgdmFsaWRhdGlvblxuY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5jb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKGBeJHtkYXRlUmVnZXhTb3VyY2V9JGApO1xuZnVuY3Rpb24gdGltZVJlZ2V4U291cmNlKGFyZ3MpIHtcbiAgICBsZXQgc2Vjb25kc1JlZ2V4U291cmNlID0gYFswLTVdXFxcXGRgO1xuICAgIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHNlY29uZHNSZWdleFNvdXJjZSA9IGAke3NlY29uZHNSZWdleFNvdXJjZX0oXFxcXC5cXFxcZCspP2A7XG4gICAgfVxuICAgIGNvbnN0IHNlY29uZHNRdWFudGlmaWVyID0gYXJncy5wcmVjaXNpb24gPyBcIitcIiA6IFwiP1wiOyAvLyByZXF1aXJlIHNlY29uZHMgaWYgcHJlY2lzaW9uIGlzIG5vbnplcm9cbiAgICByZXR1cm4gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkKDoke3NlY29uZHNSZWdleFNvdXJjZX0pJHtzZWNvbmRzUXVhbnRpZmllcn1gO1xufVxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxuZnVuY3Rpb24gZGF0ZXRpbWVSZWdleChhcmdzKSB7XG4gICAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xuICAgIGNvbnN0IG9wdHMgPSBbXTtcbiAgICBvcHRzLnB1c2goYXJncy5sb2NhbCA/IGBaP2AgOiBgWmApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcbiAgICByZWdleCA9IGAke3JlZ2V4fSgke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRKV1Qoand0LCBhbGcpIHtcbiAgICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJdID0gand0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCksIFwiPVwiKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGVjb2RlZC50eXAgfHwgIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1vamlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghbmFub2lkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZDIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdWxpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBqd3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGlwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGNpZHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgbG9jYWw6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICB0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxlbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYC5taW4oMSlgXG4gICAgICovXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG93ZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvVXBwZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEYXRlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XG4gICAgfVxuICAgIGdldCBpc1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbW9qaSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVTElEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0lQKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDSURSKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImNpZHJcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NHVybCgpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjR1cmxcIik7XG4gICAgfVxuICAgIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gcGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIE1hdGgucG93KDEwLCBkZWNDb3VudCk7XG59XG5jbGFzcyBab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfZmluaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5pdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhZmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSkuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIiB8fFxuICAgICAgICAgICAgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcImZpbml0ZVwiIHx8XG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJpbnRcIiB8fFxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICAgIH1cbn1cblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfZ2V0SW52YWxpZElucHV0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxufVxuWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogKHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgfVxuICAgIHN0cmljdChtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fZGVmKS5lcnJvck1hcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGlzc3VlLCBjdHgpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGN0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChfZCA9IGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhc3N0aHJvdWdoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gICAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxuICAgIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gICAgLy8gICA+ID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICAgIC4uLmRlZixcbiAgICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgIC8vICAgICAgIH0pLFxuICAgIC8vICAgICB9KSBhcyBhbnk7XG4gICAgLy8gICB9O1xuICAgIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBtZXJnZShtZXJnaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvLyBtZXJnZTxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH0sXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfVxuICAgIC8vID4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQsXG4gICAgLy8gICBOZXdJbnB1dFxuICAgIC8vID4ge1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAgIC8vIFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyA+IHtcbiAgICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgLy8gICAvLyApO1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXMobWFzaykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkZWVwUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xuICAgIH1cbiAgICBwYXJ0aWFsKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1aXJlZChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSBuZXdGaWVsZC5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5b2YoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gICAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZpcnN0IGlzc3VlLWZyZWUgdmFsaWRhdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGlzc3VlcyBmcm9tIGRpcnR5IG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IG5ldyBab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0geyByZXN1bHQsIGN0eDogY2hpbGRDdHggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlcykgPT4gbmV3IFpvZEVycm9yKGlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxufVxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgb3B0aW9uczogdHlwZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMYXp5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5pbm5lclR5cGUoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFbnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyh0eXBlLmVudW0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2NyaW1pbmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcCxcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3NcbiAgICAgICAgICAgICAgICA/IGFyZ3NcbiAgICAgICAgICAgICAgICA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9ab2RFbnVtX2NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmNsYXNzIFpvZE5hdGl2ZUVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgX1pvZE5hdGl2ZUVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5fWm9kTmF0aXZlRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiZcbiAgICAgICAgICAgIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2VcbiAgICAgICAgICAgID8gY3R4LmRhdGFcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgaW5uZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgc291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBwYXRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgucGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQ3R4LmFkZElzc3VlID0gY2hlY2tDdHguYWRkSXNzdWUuYmluZChjaGVja0N0eCk7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcbiAgICAgICAgICAgIDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5jbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5jbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBjb25zdCBmcmVlemUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNBc3luYyhyZXN1bHQpXG4gICAgICAgICAgICA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpXG4gICAgICAgICAgICA6IGZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIHouY3VzdG9tICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHBhcmFtcyhkYXRhKVxuICAgICAgICA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8geyBtZXNzYWdlOiBwYXJhbXMgfVxuICAgICAgICAgICAgOiBwYXJhbXM7XG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICByZXR1cm4gcDI7XG59XG5mdW5jdGlvbiBjdXN0b20oY2hlY2ssIF9wYXJhbXMgPSB7fSwgXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcbiAqXG4gKiBgYGB0c1xuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXG4gKiBgYGBcbiAqXG4gKi9cbmZhdGFsKSB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCByID0gY2hlY2soZGF0YSk7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbmNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG5jbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3QgY29lcmNlID0ge1xuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgbnVtYmVyOiAoKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xuICAgICAgICAuLi5hcmcsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICB9KSksXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBkYXRlOiAoKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG59O1xuY29uc3QgTkVWRVIgPSBJTlZBTElEO1xuXG52YXIgeiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZGVmYXVsdEVycm9yTWFwOiBlcnJvck1hcCxcbiAgICBzZXRFcnJvck1hcDogc2V0RXJyb3JNYXAsXG4gICAgZ2V0RXJyb3JNYXA6IGdldEVycm9yTWFwLFxuICAgIG1ha2VJc3N1ZTogbWFrZUlzc3VlLFxuICAgIEVNUFRZX1BBVEg6IEVNUFRZX1BBVEgsXG4gICAgYWRkSXNzdWVUb0NvbnRleHQ6IGFkZElzc3VlVG9Db250ZXh0LFxuICAgIFBhcnNlU3RhdHVzOiBQYXJzZVN0YXR1cyxcbiAgICBJTlZBTElEOiBJTlZBTElELFxuICAgIERJUlRZOiBESVJUWSxcbiAgICBPSzogT0ssXG4gICAgaXNBYm9ydGVkOiBpc0Fib3J0ZWQsXG4gICAgaXNEaXJ0eTogaXNEaXJ0eSxcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGlzQXN5bmM6IGlzQXN5bmMsXG4gICAgZ2V0IHV0aWwgKCkgeyByZXR1cm4gdXRpbDsgfSxcbiAgICBnZXQgb2JqZWN0VXRpbCAoKSB7IHJldHVybiBvYmplY3RVdGlsOyB9LFxuICAgIFpvZFBhcnNlZFR5cGU6IFpvZFBhcnNlZFR5cGUsXG4gICAgZ2V0UGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZSxcbiAgICBab2RUeXBlOiBab2RUeXBlLFxuICAgIGRhdGV0aW1lUmVnZXg6IGRhdGV0aW1lUmVnZXgsXG4gICAgWm9kU3RyaW5nOiBab2RTdHJpbmcsXG4gICAgWm9kTnVtYmVyOiBab2ROdW1iZXIsXG4gICAgWm9kQmlnSW50OiBab2RCaWdJbnQsXG4gICAgWm9kQm9vbGVhbjogWm9kQm9vbGVhbixcbiAgICBab2REYXRlOiBab2REYXRlLFxuICAgIFpvZFN5bWJvbDogWm9kU3ltYm9sLFxuICAgIFpvZFVuZGVmaW5lZDogWm9kVW5kZWZpbmVkLFxuICAgIFpvZE51bGw6IFpvZE51bGwsXG4gICAgWm9kQW55OiBab2RBbnksXG4gICAgWm9kVW5rbm93bjogWm9kVW5rbm93bixcbiAgICBab2ROZXZlcjogWm9kTmV2ZXIsXG4gICAgWm9kVm9pZDogWm9kVm9pZCxcbiAgICBab2RBcnJheTogWm9kQXJyYXksXG4gICAgWm9kT2JqZWN0OiBab2RPYmplY3QsXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogWm9kSW50ZXJzZWN0aW9uLFxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcbiAgICBab2RNYXA6IFpvZE1hcCxcbiAgICBab2RTZXQ6IFpvZFNldCxcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXG4gICAgWm9kTGF6eTogWm9kTGF6eSxcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxuICAgIFpvZEVudW06IFpvZEVudW0sXG4gICAgWm9kTmF0aXZlRW51bTogWm9kTmF0aXZlRW51bSxcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcbiAgICBab2REZWZhdWx0OiBab2REZWZhdWx0LFxuICAgIFpvZENhdGNoOiBab2RDYXRjaCxcbiAgICBab2ROYU46IFpvZE5hTixcbiAgICBCUkFORDogQlJBTkQsXG4gICAgWm9kQnJhbmRlZDogWm9kQnJhbmRlZCxcbiAgICBab2RQaXBlbGluZTogWm9kUGlwZWxpbmUsXG4gICAgWm9kUmVhZG9ubHk6IFpvZFJlYWRvbmx5LFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBjb2VyY2U6IGNvZXJjZSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NUeXBlLFxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxuICAgIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgICBzZXQ6IHNldFR5cGUsXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxuICAgIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIE5FVkVSOiBORVZFUixcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcbiAgICBxdW90ZWxlc3NKc29uOiBxdW90ZWxlc3NKc29uLFxuICAgIFpvZEVycm9yOiBab2RFcnJvclxufSk7XG5cbmV4cG9ydCB7IEJSQU5ELCBESVJUWSwgRU1QVFlfUEFUSCwgSU5WQUxJRCwgTkVWRVIsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kQnJhbmRlZCwgWm9kQ2F0Y2gsIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFBpcGVsaW5lLCBab2RQcm9taXNlLCBab2RSZWFkb25seSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZFN5bWJvbCwgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciwgWm9kVHVwbGUsIFpvZFR5cGUsIFpvZFVuZGVmaW5lZCwgWm9kVW5pb24sIFpvZFVua25vd24sIFpvZFZvaWQsIGFkZElzc3VlVG9Db250ZXh0LCBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgY29lcmNlLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIGRhdGV0aW1lUmVnZXgsIHogYXMgZGVmYXVsdCwgZXJyb3JNYXAgYXMgZGVmYXVsdEVycm9yTWFwLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGdldEVycm9yTWFwLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCBxdW90ZWxlc3NKc29uLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHNldEVycm9yTWFwLCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB1dGlsLCB2b2lkVHlwZSBhcyB2b2lkLCB6IH07XG4iXSwibmFtZXMiOlsidXRpbCIsImFzc2VydEVxdWFsIiwidmFsIiwiYXNzZXJ0SXMiLCJfYXJnIiwiYXNzZXJ0TmV2ZXIiLCJfeCIsIkVycm9yIiwiYXJyYXlUb0VudW0iLCJpdGVtcyIsIm9iaiIsIml0ZW0iLCJnZXRWYWxpZEVudW1WYWx1ZXMiLCJ2YWxpZEtleXMiLCJvYmplY3RLZXlzIiwiZmlsdGVyIiwiayIsImZpbHRlcmVkIiwib2JqZWN0VmFsdWVzIiwibWFwIiwiZSIsIk9iamVjdCIsImtleXMiLCJvYmplY3QiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwdXNoIiwiZmluZCIsImFyciIsImNoZWNrZXIiLCJ1bmRlZmluZWQiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hdGgiLCJmbG9vciIsImpvaW5WYWx1ZXMiLCJhcnJheSIsInNlcGFyYXRvciIsImpvaW4iLCJqc29uU3RyaW5naWZ5UmVwbGFjZXIiLCJfIiwidmFsdWUiLCJ0b1N0cmluZyIsIm9iamVjdFV0aWwiLCJtZXJnZVNoYXBlcyIsImZpcnN0Iiwic2Vjb25kIiwiWm9kUGFyc2VkVHlwZSIsImdldFBhcnNlZFR5cGUiLCJkYXRhIiwidCIsInN0cmluZyIsImlzTmFOIiwibmFuIiwibnVtYmVyIiwiYm9vbGVhbiIsImZ1bmN0aW9uIiwiYmlnaW50Iiwic3ltYm9sIiwiQXJyYXkiLCJpc0FycmF5IiwibnVsbCIsInRoZW4iLCJjYXRjaCIsInByb21pc2UiLCJNYXAiLCJTZXQiLCJzZXQiLCJEYXRlIiwiZGF0ZSIsInVua25vd24iLCJab2RJc3N1ZUNvZGUiLCJxdW90ZWxlc3NKc29uIiwianNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXBsYWNlIiwiWm9kRXJyb3IiLCJlcnJvcnMiLCJpc3N1ZXMiLCJjb25zdHJ1Y3RvciIsImFkZElzc3VlIiwic3ViIiwiYWRkSXNzdWVzIiwic3VicyIsImFjdHVhbFByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJuYW1lIiwiZm9ybWF0IiwiX21hcHBlciIsIm1hcHBlciIsImlzc3VlIiwibWVzc2FnZSIsImZpZWxkRXJyb3JzIiwiX2Vycm9ycyIsInByb2Nlc3NFcnJvciIsImVycm9yIiwiY29kZSIsInVuaW9uRXJyb3JzIiwicmV0dXJuVHlwZUVycm9yIiwiYXJndW1lbnRzRXJyb3IiLCJwYXRoIiwibGVuZ3RoIiwiY3VyciIsImkiLCJlbCIsInRlcm1pbmFsIiwiYXNzZXJ0IiwiaXNFbXB0eSIsImZsYXR0ZW4iLCJmb3JtRXJyb3JzIiwiY3JlYXRlIiwiZXJyb3JNYXAiLCJfY3R4IiwiaW52YWxpZF90eXBlIiwicmVjZWl2ZWQiLCJleHBlY3RlZCIsImludmFsaWRfbGl0ZXJhbCIsInVucmVjb2duaXplZF9rZXlzIiwiaW52YWxpZF91bmlvbiIsImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvciIsIm9wdGlvbnMiLCJpbnZhbGlkX2VudW1fdmFsdWUiLCJpbnZhbGlkX2FyZ3VtZW50cyIsImludmFsaWRfcmV0dXJuX3R5cGUiLCJpbnZhbGlkX2RhdGUiLCJpbnZhbGlkX3N0cmluZyIsInZhbGlkYXRpb24iLCJpbmNsdWRlcyIsInBvc2l0aW9uIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidG9vX3NtYWxsIiwidHlwZSIsImV4YWN0IiwiaW5jbHVzaXZlIiwibWluaW11bSIsInRvb19iaWciLCJtYXhpbXVtIiwiY3VzdG9tIiwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMiLCJub3RfbXVsdGlwbGVfb2YiLCJtdWx0aXBsZU9mIiwibm90X2Zpbml0ZSIsImRlZmF1bHRFcnJvciIsIm92ZXJyaWRlRXJyb3JNYXAiLCJzZXRFcnJvck1hcCIsImdldEVycm9yTWFwIiwibWFrZUlzc3VlIiwicGFyYW1zIiwiZXJyb3JNYXBzIiwiaXNzdWVEYXRhIiwiZnVsbFBhdGgiLCJmdWxsSXNzdWUiLCJlcnJvck1lc3NhZ2UiLCJtYXBzIiwibSIsInNsaWNlIiwicmV2ZXJzZSIsIkVNUFRZX1BBVEgiLCJhZGRJc3N1ZVRvQ29udGV4dCIsImN0eCIsIm92ZXJyaWRlTWFwIiwiY29tbW9uIiwiY29udGV4dHVhbEVycm9yTWFwIiwic2NoZW1hRXJyb3JNYXAiLCJ4IiwiUGFyc2VTdGF0dXMiLCJkaXJ0eSIsImFib3J0IiwibWVyZ2VBcnJheSIsInN0YXR1cyIsInJlc3VsdHMiLCJhcnJheVZhbHVlIiwicyIsIklOVkFMSUQiLCJtZXJnZU9iamVjdEFzeW5jIiwicGFpcnMiLCJzeW5jUGFpcnMiLCJwYWlyIiwibWVyZ2VPYmplY3RTeW5jIiwiZmluYWxPYmplY3QiLCJhbHdheXNTZXQiLCJmcmVlemUiLCJESVJUWSIsIk9LIiwiaXNBYm9ydGVkIiwiaXNEaXJ0eSIsImlzVmFsaWQiLCJpc0FzeW5jIiwiUHJvbWlzZSIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwia2luZCIsImYiLCJUeXBlRXJyb3IiLCJoYXMiLCJnZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwiU3VwcHJlc3NlZEVycm9yIiwic3VwcHJlc3NlZCIsImVycm9yVXRpbCIsImVyclRvT2JqIiwiX1pvZEVudW1fY2FjaGUiLCJfWm9kTmF0aXZlRW51bV9jYWNoZSIsIlBhcnNlSW5wdXRMYXp5UGF0aCIsInBhcmVudCIsIl9jYWNoZWRQYXRoIiwiX3BhdGgiLCJfa2V5IiwiaGFuZGxlUmVzdWx0IiwicmVzdWx0Iiwic3VjY2VzcyIsIl9lcnJvciIsInByb2Nlc3NDcmVhdGVQYXJhbXMiLCJpbnZhbGlkX3R5cGVfZXJyb3IiLCJyZXF1aXJlZF9lcnJvciIsImRlc2NyaXB0aW9uIiwiY3VzdG9tTWFwIiwiaXNzIiwiX2EiLCJfYiIsIlpvZFR5cGUiLCJfZGVmIiwiX2dldFR5cGUiLCJpbnB1dCIsIl9nZXRPclJldHVybkN0eCIsInBhcnNlZFR5cGUiLCJfcHJvY2Vzc0lucHV0UGFyYW1zIiwiX3BhcnNlU3luYyIsIl9wYXJzZSIsIl9wYXJzZUFzeW5jIiwicmVzb2x2ZSIsInBhcnNlIiwic2FmZVBhcnNlIiwiYXN5bmMiLCJlcnIiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlQXN5bmMiLCJzYWZlUGFyc2VBc3luYyIsIm1heWJlQXN5bmNSZXN1bHQiLCJyZWZpbmUiLCJjaGVjayIsImdldElzc3VlUHJvcGVydGllcyIsIl9yZWZpbmVtZW50Iiwic2V0RXJyb3IiLCJyZWZpbmVtZW50IiwicmVmaW5lbWVudERhdGEiLCJab2RFZmZlY3RzIiwic2NoZW1hIiwidHlwZU5hbWUiLCJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCJlZmZlY3QiLCJzdXBlclJlZmluZSIsImRlZiIsInNwYSIsImJpbmQiLCJvcHRpb25hbCIsIm51bGxhYmxlIiwibnVsbGlzaCIsIm9yIiwiYW5kIiwidHJhbnNmb3JtIiwiYnJhbmQiLCJkZWZhdWx0IiwiZGVzY3JpYmUiLCJwaXBlIiwicmVhZG9ubHkiLCJpc051bGxhYmxlIiwiaXNPcHRpb25hbCIsInZlcnNpb24iLCJ2ZW5kb3IiLCJ2YWxpZGF0ZSIsIlpvZE9wdGlvbmFsIiwiWm9kTnVsbGFibGUiLCJab2RBcnJheSIsIlpvZFByb21pc2UiLCJvcHRpb24iLCJab2RVbmlvbiIsImluY29taW5nIiwiWm9kSW50ZXJzZWN0aW9uIiwiZGVmYXVsdFZhbHVlRnVuYyIsIlpvZERlZmF1bHQiLCJpbm5lclR5cGUiLCJkZWZhdWx0VmFsdWUiLCJab2RCcmFuZGVkIiwiY2F0Y2hWYWx1ZUZ1bmMiLCJab2RDYXRjaCIsImNhdGNoVmFsdWUiLCJUaGlzIiwidGFyZ2V0IiwiWm9kUGlwZWxpbmUiLCJab2RSZWFkb25seSIsImN1aWRSZWdleCIsImN1aWQyUmVnZXgiLCJ1bGlkUmVnZXgiLCJ1dWlkUmVnZXgiLCJuYW5vaWRSZWdleCIsImp3dFJlZ2V4IiwiZHVyYXRpb25SZWdleCIsImVtYWlsUmVnZXgiLCJfZW1vamlSZWdleCIsImVtb2ppUmVnZXgiLCJpcHY0UmVnZXgiLCJpcHY0Q2lkclJlZ2V4IiwiaXB2NlJlZ2V4IiwiaXB2NkNpZHJSZWdleCIsImJhc2U2NFJlZ2V4IiwiYmFzZTY0dXJsUmVnZXgiLCJkYXRlUmVnZXhTb3VyY2UiLCJkYXRlUmVnZXgiLCJSZWdFeHAiLCJ0aW1lUmVnZXhTb3VyY2UiLCJhcmdzIiwic2Vjb25kc1JlZ2V4U291cmNlIiwicHJlY2lzaW9uIiwic2Vjb25kc1F1YW50aWZpZXIiLCJ0aW1lUmVnZXgiLCJkYXRldGltZVJlZ2V4IiwicmVnZXgiLCJvcHRzIiwibG9jYWwiLCJvZmZzZXQiLCJpc1ZhbGlkSVAiLCJpcCIsInRlc3QiLCJpc1ZhbGlkSldUIiwiand0IiwiYWxnIiwiaGVhZGVyIiwic3BsaXQiLCJiYXNlNjQiLCJwYWRFbmQiLCJkZWNvZGVkIiwiYXRvYiIsInR5cCIsImlzVmFsaWRDaWRyIiwiWm9kU3RyaW5nIiwiY29lcmNlIiwiU3RyaW5nIiwiY2hlY2tzIiwidG9vQmlnIiwidG9vU21hbGwiLCJVUkwiLCJsYXN0SW5kZXgiLCJ0ZXN0UmVzdWx0IiwidHJpbSIsInRvVXBwZXJDYXNlIiwiX3JlZ2V4IiwiX2FkZENoZWNrIiwiZW1haWwiLCJ1cmwiLCJlbW9qaSIsInV1aWQiLCJuYW5vaWQiLCJjdWlkIiwiY3VpZDIiLCJ1bGlkIiwiYmFzZTY0dXJsIiwiY2lkciIsImRhdGV0aW1lIiwidGltZSIsImR1cmF0aW9uIiwibWluIiwibWluTGVuZ3RoIiwibWF4IiwibWF4TGVuZ3RoIiwibGVuIiwibm9uZW1wdHkiLCJpc0RhdGV0aW1lIiwiY2giLCJpc0RhdGUiLCJpc1RpbWUiLCJpc0R1cmF0aW9uIiwiaXNFbWFpbCIsImlzVVJMIiwiaXNFbW9qaSIsImlzVVVJRCIsImlzTkFOT0lEIiwiaXNDVUlEIiwiaXNDVUlEMiIsImlzVUxJRCIsImlzSVAiLCJpc0NJRFIiLCJpc0Jhc2U2NCIsImlzQmFzZTY0dXJsIiwiZmxvYXRTYWZlUmVtYWluZGVyIiwic3RlcCIsInZhbERlY0NvdW50Iiwic3RlcERlY0NvdW50IiwiZGVjQ291bnQiLCJ2YWxJbnQiLCJwYXJzZUludCIsInRvRml4ZWQiLCJzdGVwSW50IiwicG93IiwiWm9kTnVtYmVyIiwiYXJndW1lbnRzIiwiZ3RlIiwibHRlIiwic2V0TGltaXQiLCJndCIsImx0IiwiaW50IiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsIm5vbnBvc2l0aXZlIiwibm9ubmVnYXRpdmUiLCJmaW5pdGUiLCJzYWZlIiwiTUlOX1NBRkVfSU5URUdFUiIsIk1BWF9TQUZFX0lOVEVHRVIiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiaXNJbnQiLCJab2RCaWdJbnQiLCJCaWdJbnQiLCJfZ2V0SW52YWxpZElucHV0IiwiWm9kQm9vbGVhbiIsIkJvb2xlYW4iLCJab2REYXRlIiwiZ2V0VGltZSIsIm1pbkRhdGUiLCJtYXhEYXRlIiwiWm9kU3ltYm9sIiwiWm9kVW5kZWZpbmVkIiwiWm9kTnVsbCIsIlpvZEFueSIsIl9hbnkiLCJab2RVbmtub3duIiwiX3Vua25vd24iLCJab2ROZXZlciIsIm5ldmVyIiwiWm9kVm9pZCIsInZvaWQiLCJleGFjdExlbmd0aCIsImFsbCIsImVsZW1lbnQiLCJkZWVwUGFydGlhbGlmeSIsIlpvZE9iamVjdCIsIm5ld1NoYXBlIiwic2hhcGUiLCJmaWVsZFNjaGVtYSIsInVud3JhcCIsIlpvZFR1cGxlIiwiX2NhY2hlZCIsIm5vbnN0cmljdCIsInBhc3N0aHJvdWdoIiwiYXVnbWVudCIsImV4dGVuZCIsIl9nZXRDYWNoZWQiLCJzaGFwZUtleXMiLCJleHRyYUtleXMiLCJjYXRjaGFsbCIsInVua25vd25LZXlzIiwia2V5VmFsaWRhdG9yIiwic3RyaWN0IiwiX2MiLCJfZCIsInN0cmlwIiwiYXVnbWVudGF0aW9uIiwibWVyZ2UiLCJtZXJnaW5nIiwibWVyZ2VkIiwic2V0S2V5IiwiaW5kZXgiLCJwaWNrIiwibWFzayIsImZvckVhY2giLCJvbWl0IiwiZGVlcFBhcnRpYWwiLCJwYXJ0aWFsIiwicmVxdWlyZWQiLCJuZXdGaWVsZCIsImtleW9mIiwiY3JlYXRlWm9kRW51bSIsInN0cmljdENyZWF0ZSIsImxhenljcmVhdGUiLCJoYW5kbGVSZXN1bHRzIiwiY2hpbGRDdHgiLCJ0eXBlcyIsImdldERpc2NyaW1pbmF0b3IiLCJab2RMYXp5IiwiWm9kTGl0ZXJhbCIsIlpvZEVudW0iLCJab2ROYXRpdmVFbnVtIiwiZW51bSIsIlpvZERpc2NyaW1pbmF0ZWRVbmlvbiIsImRpc2NyaW1pbmF0b3IiLCJkaXNjcmltaW5hdG9yVmFsdWUiLCJvcHRpb25zTWFwIiwiZnJvbSIsImRpc2NyaW1pbmF0b3JWYWx1ZXMiLCJtZXJnZVZhbHVlcyIsImEiLCJiIiwiYVR5cGUiLCJiVHlwZSIsInZhbGlkIiwiYktleXMiLCJzaGFyZWRLZXlzIiwiaW5kZXhPZiIsIm5ld09iaiIsInNoYXJlZFZhbHVlIiwibmV3QXJyYXkiLCJpdGVtQSIsIml0ZW1CIiwiaGFuZGxlUGFyc2VkIiwicGFyc2VkTGVmdCIsInBhcnNlZFJpZ2h0IiwibGVmdCIsInJpZ2h0IiwicmVzdCIsIml0ZW1JbmRleCIsInNjaGVtYXMiLCJab2RSZWNvcmQiLCJrZXlTY2hlbWEiLCJrZXlUeXBlIiwidmFsdWVTY2hlbWEiLCJ2YWx1ZVR5cGUiLCJ0aGlyZCIsIlpvZE1hcCIsImVudHJpZXMiLCJmaW5hbE1hcCIsIlpvZFNldCIsIm1pblNpemUiLCJzaXplIiwibWF4U2l6ZSIsImZpbmFsaXplU2V0IiwiZWxlbWVudHMiLCJwYXJzZWRTZXQiLCJhZGQiLCJ2YWx1ZXMiLCJab2RGdW5jdGlvbiIsImltcGxlbWVudCIsIm1ha2VBcmdzSXNzdWUiLCJtYWtlUmV0dXJuc0lzc3VlIiwicmV0dXJucyIsImZuIiwibWUiLCJwYXJzZWRBcmdzIiwiUmVmbGVjdCIsImFwcGx5IiwicGFyc2VkUmV0dXJucyIsInBhcmFtZXRlcnMiLCJyZXR1cm5UeXBlIiwiZnVuYyIsInZhbGlkYXRlZEZ1bmMiLCJzdHJpY3RJbXBsZW1lbnQiLCJnZXR0ZXIiLCJsYXp5U2NoZW1hIiwiZXhwZWN0ZWRWYWx1ZXMiLCJlbnVtVmFsdWVzIiwiVmFsdWVzIiwiRW51bSIsImV4dHJhY3QiLCJuZXdEZWYiLCJleGNsdWRlIiwib3B0IiwiV2Vha01hcCIsIm5hdGl2ZUVudW1WYWx1ZXMiLCJwcm9taXNpZmllZCIsInNvdXJjZVR5cGUiLCJjaGVja0N0eCIsImFyZyIsImZhdGFsIiwicHJvY2Vzc2VkIiwiZXhlY3V0ZVJlZmluZW1lbnQiLCJhY2MiLCJpbm5lciIsImJhc2UiLCJjcmVhdGVXaXRoUHJlcHJvY2VzcyIsInByZXByb2Nlc3MiLCJyZW1vdmVEZWZhdWx0IiwibmV3Q3R4IiwicmVtb3ZlQ2F0Y2giLCJab2ROYU4iLCJCUkFORCIsIlN5bWJvbCIsImhhbmRsZUFzeW5jIiwiaW5SZXN1bHQiLCJpbiIsIm91dCIsImNsZWFuUGFyYW1zIiwicCIsInAyIiwiX3BhcmFtcyIsInIiLCJfZmF0YWwiLCJsYXRlIiwiaW5zdGFuY2VPZlR5cGUiLCJjbHMiLCJzdHJpbmdUeXBlIiwibnVtYmVyVHlwZSIsIm5hblR5cGUiLCJiaWdJbnRUeXBlIiwiYm9vbGVhblR5cGUiLCJkYXRlVHlwZSIsInN5bWJvbFR5cGUiLCJ1bmRlZmluZWRUeXBlIiwibnVsbFR5cGUiLCJhbnlUeXBlIiwidW5rbm93blR5cGUiLCJuZXZlclR5cGUiLCJ2b2lkVHlwZSIsImFycmF5VHlwZSIsIm9iamVjdFR5cGUiLCJzdHJpY3RPYmplY3RUeXBlIiwidW5pb25UeXBlIiwiZGlzY3JpbWluYXRlZFVuaW9uVHlwZSIsImludGVyc2VjdGlvblR5cGUiLCJ0dXBsZVR5cGUiLCJyZWNvcmRUeXBlIiwibWFwVHlwZSIsInNldFR5cGUiLCJmdW5jdGlvblR5cGUiLCJsYXp5VHlwZSIsImxpdGVyYWxUeXBlIiwiZW51bVR5cGUiLCJuYXRpdmVFbnVtVHlwZSIsInByb21pc2VUeXBlIiwiZWZmZWN0c1R5cGUiLCJvcHRpb25hbFR5cGUiLCJudWxsYWJsZVR5cGUiLCJwcmVwcm9jZXNzVHlwZSIsInBpcGVsaW5lVHlwZSIsIm9zdHJpbmciLCJvbnVtYmVyIiwib2Jvb2xlYW4iLCJORVZFUiIsInoiLCJkZWZhdWx0RXJyb3JNYXAiLCJab2RUcmFuc2Zvcm1lciIsIlNjaGVtYSIsIlpvZFNjaGVtYSIsImFueSIsImRpc2NyaW1pbmF0ZWRVbmlvbiIsImludGVyc2VjdGlvbiIsImxhenkiLCJsaXRlcmFsIiwibmF0aXZlRW51bSIsInBpcGVsaW5lIiwicmVjb3JkIiwic3RyaWN0T2JqZWN0IiwidHJhbnNmb3JtZXIiLCJ0dXBsZSIsInVuaW9uIiwiaW5zdGFuY2VvZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/zod/lib/index.mjs\n");

/***/ })

};
;